/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/app': {
    /** This method returns the application settings */
    get: operations['GetApp'];
    /** This method updates one or more application settings */
    patch: operations['UpdateApp'];
  };
  '/blocklists': {
    /** Returns all available block lists */
    get: operations['ListBlockLists'];
    /** Creates a new application blocklist, once created the blocklist can be used by any channel type */
    post: operations['CreateBlockList'];
  };
  '/blocklists/{name}': {
    /** Returns block list by given name */
    get: operations['GetBlockList'];
    /** Updates contents of the block list */
    put: operations['UpdateBlockList'];
    /** Deletes previously created application blocklist */
    delete: operations['DeleteBlockList'];
  };
  '/campaigns': {
    /** List campaigns */
    get: operations['ListCampaigns'];
    /** Creates a new campaign */
    post: operations['CreateCampaign'];
  };
  '/campaigns/{id}': {
    /** Get a campaign */
    get: operations['GetCampaign'];
    /** Update an existing campaign */
    put: operations['UpdateCampaign'];
    /** Delete a campaign */
    delete: operations['DeleteCampaign'];
  };
  '/campaigns/{id}/resume': {
    /** Resume a stopped campaign */
    patch: operations['ResumeCampaign'];
  };
  '/campaigns/{id}/schedule': {
    /** Schedule a campaign */
    patch: operations['ScheduleCampaign'];
  };
  '/campaigns/{id}/stop': {
    /** Stop a running campaign */
    patch: operations['StopCampaign'];
  };
  '/campaigns/{id}/test': {
    /** Test a campaign */
    post: operations['TestCampaign'];
  };
  '/channels': {
    /** Query channels with filter query */
    post: operations['QueryChannels'];
  };
  '/channels/delete': {
    /** Allows to delete several channels at once asynchronously */
    post: operations['DeleteChannels'];
  };
  '/channels/read': {
    /** Marks all user channels as read */
    post: operations['MarkAllRead'];
  };
  '/channels/{type}/query': {
    /** This method creates a channel or returns an existing one with matching attributes */
    post: operations['GetOrCreateChannel_type'];
  };
  '/channels/{type}/{id}': {
    /** Change channel data */
    post: operations['UpdateChannel'];
    /** Deletes channel */
    delete: operations['DeleteChannel'];
    /** Updates certain fields of the channel */
    patch: operations['UpdateChannelPartial'];
  };
  '/channels/{type}/{id}/event': {
    /** Sends event to the channel */
    post: operations['SendEvent'];
  };
  '/channels/{type}/{id}/file': {
    /** Uploads file */
    post: operations['UploadFile'];
    /** Deletes previously uploaded file */
    delete: operations['DeleteFile'];
  };
  '/channels/{type}/{id}/hide': {
    /** Marks channel as hidden for current user */
    post: operations['HideChannel'];
  };
  '/channels/{type}/{id}/image': {
    /** Uploads image */
    post: operations['UploadImage'];
    /** Deletes previously uploaded image */
    delete: operations['DeleteImage'];
  };
  '/channels/{type}/{id}/message': {
    /** Sends new message to the specified channel */
    post: operations['SendMessage'];
  };
  '/channels/{type}/{id}/messages': {
    /** Returns list messages found by IDs */
    get: operations['GetManyMessages'];
  };
  '/channels/{type}/{id}/query': {
    /** This method creates a channel or returns an existing one with matching attributes */
    post: operations['GetOrCreateChannel_type_id'];
  };
  '/channels/{type}/{id}/read': {
    /** Marks channel as read up to the specific message */
    post: operations['MarkRead'];
  };
  '/channels/{type}/{id}/show': {
    /** Shows previously hidden channel */
    post: operations['ShowChannel'];
  };
  '/channels/{type}/{id}/stop-watching': {
    /** Call this method to stop receiving channel events */
    post: operations['StopWatchingChannel'];
  };
  '/channels/{type}/{id}/truncate': {
    /** Truncates channel */
    post: operations['TruncateChannel'];
  };
  '/channeltypes': {
    /** Lists all available channel types */
    get: operations['ListChannelTypes'];
    /** Creates new channel type */
    post: operations['CreateChannelType'];
  };
  '/channeltypes/{name}': {
    /** Gets channel type */
    get: operations['GetChannelType'];
    /** Updates channel type */
    put: operations['UpdateChannelType'];
    /** Deletes channel type */
    delete: operations['DeleteChannelType'];
  };
  '/check_push': {
    /** Sends a test message via push, this is a test endpoint to verify your push settings */
    post: operations['CheckPush'];
  };
  '/check_sqs': {
    /** Validates Amazon SQS credentials */
    post: operations['CheckSQS'];
  };
  '/commands': {
    /** Returns all custom commands */
    get: operations['ListCommands'];
    /** Creates custom chat command */
    post: operations['CreateCommand'];
  };
  '/commands/{name}': {
    /** Returns custom command by its name */
    get: operations['GetCommand'];
    /** Updates custom chat command */
    put: operations['UpdateCommand'];
    /** Deletes custom chat command */
    delete: operations['DeleteCommand'];
  };
  '/connect': {
    /** Establishes WebSocket connection for user */
    get: operations['Connect'];
  };
  '/devices': {
    /** Returns all available devices */
    get: operations['ListDevices'];
    /** Adds a new device to a user, if the same device already exists the call will have no effect */
    post: operations['CreateDevice'];
    /** Deletes device */
    delete: operations['DeleteDevice'];
  };
  '/export_channels': {
    /** Exports channel data to JSON file */
    post: operations['ExportChannels'];
  };
  '/export_channels/{id}': {
    get: operations['GetExportChannelsStatus'];
  };
  '/guest': {
    /** Creates guest user */
    post: operations['CreateGuest'];
  };
  '/members': {
    /** Find and filter channel members */
    get: operations['QueryMembers'];
  };
  '/messages/{id}': {
    /** Returns message by ID */
    get: operations['GetMessage'];
    /** Updates certain fields of the message */
    put: operations['UpdateMessagePartial'];
    /** Updates message with new data */
    post: operations['UpdateMessage'];
    /** Deletes message */
    delete: operations['DeleteMessage'];
  };
  '/messages/{id}/action': {
    /** Executes message command action with given parameters */
    post: operations['RunMessageAction'];
  };
  '/messages/{id}/reaction': {
    /** Sends reaction to specified message */
    post: operations['SendReaction'];
  };
  '/messages/{id}/reaction/{type}': {
    /** Removes user reaction from the message */
    delete: operations['DeleteReaction'];
  };
  '/messages/{id}/reactions': {
    /** Returns list of reactions of specific message */
    get: operations['GetReactions'];
  };
  '/messages/{id}/translate': {
    /** Translates message to a given language using automated translation software */
    post: operations['TranslateMessage'];
  };
  '/messages/{parent_id}/replies': {
    /** Returns replies (thread) of the message */
    get: operations['GetReplies'];
  };
  '/moderation/ban': {
    /** Restricts user activity either in specific channel or globally */
    post: operations['Ban'];
    /** Removes previously applied ban */
    delete: operations['Unban'];
  };
  '/moderation/flag': {
    /** Reports message or user for review by moderators */
    post: operations['Flag'];
  };
  '/moderation/flags/message': {
    /** Find and filter message flags */
    get: operations['QueryMessageFlags'];
  };
  '/moderation/mute': {
    /** Mutes one or several users */
    post: operations['MuteUser'];
  };
  '/moderation/mute/channel': {
    /** Mutes channel for user */
    post: operations['MuteChannel'];
  };
  '/moderation/unflag': {
    /** Removes previously created user or message flag */
    post: operations['Unflag'];
  };
  '/moderation/unmute': {
    /** Unmutes previously muted user */
    post: operations['UnmuteUser'];
  };
  '/moderation/unmute/channel': {
    /** Unmutes channel for user */
    post: operations['UnmuteChannel'];
  };
  '/og': {
    /** Get an OpenGraph attachment for a link */
    get: operations['GetOG'];
  };
  '/permissions': {
    /** Lists all available permissions */
    get: operations['ListPermissions'];
  };
  '/permissions/{id}': {
    /** Gets custom permission */
    get: operations['GetPermission'];
  };
  '/query_banned_users': {
    /** Find and filter channel scoped or global user bans */
    get: operations['QueryBannedUsers'];
  };
  '/rate_limits': {
    /** Get rate limits usage and quotas */
    get: operations['GetRateLimits'];
  };
  '/roles': {
    /** Lists all available roles */
    get: operations['ListRoles'];
    /** Creates custom role */
    post: operations['CreateRole'];
  };
  '/roles/{name}': {
    /** Deletes custom role */
    delete: operations['DeleteRole'];
  };
  '/search': {
    /** Search messages across channels */
    get: operations['Search'];
  };
  '/segments': {
    /** List segments */
    get: operations['ListSegments'];
    /** Create a segment */
    post: operations['CreateSegment'];
  };
  '/segments/{id}': {
    /** Get a segment */
    get: operations['GetSegment'];
    /** Update an existing segment */
    put: operations['UpdateSegment'];
    /** Delete a segment */
    delete: operations['DeleteSegment'];
  };
  '/sync': {
    /** Returns all events happened since client disconnect in specified channels */
    post: operations['Sync'];
  };
  '/tasks/{id}': {
    /** Gets status of a task */
    get: operations['GetTask'];
  };
  '/users': {
    /** Find and filter users */
    get: operations['QueryUsers'];
    /** Update or create users in bulk */
    post: operations['UpdateUsers'];
    /** Updates certain fields of the user */
    patch: operations['UpdateUsersPartial'];
  };
  '/users/{user_id}': {
    /** Deletes user and optionally all their belongings */
    delete: operations['DeleteUser'];
  };
  '/users/{user_id}/deactivate': {
    /** Deactivates user with possibility to activate it back */
    post: operations['DeactivateUser'];
  };
  '/users/{user_id}/event': {
    /** Sends a custom event to a user */
    post: operations['SendUserCustomEvent'];
  };
  '/users/{user_id}/export': {
    /** Exports the user's profile, reactions and messages. Raises an error if a user has more than 10k messages or reactions */
    get: operations['ExportUser'];
  };
  '/users/{user_id}/reactivate': {
    /** Activates user who's been deactivated previously */
    post: operations['ReactivateUser'];
  };
}

export interface components {
  schemas: {
    APIError: {
      /** Response HTTP status code */
      StatusCode?: number;
      /** API error code */
      code?: number;
      /** Request duration */
      duration?: string;
      /** Additional error info */
      exception_fields?: { [key: string]: string };
      /** Message describing an error */
      message?: string;
      /** URL with additional information */
      more_info?: string;
    } | null;
    APNConfigFields: {
      auth_type?: string;
      bundle_id?: string;
      development?: boolean;
      enabled?: boolean;
      host?: string;
      key_id?: string;
      notification_template?: string;
      team_id?: string;
    };
    APNConfigRequest: {
      auth_key?: string;
      auth_type?: 'certificate' | 'token';
      bundle_id?: string;
      development?: boolean;
      host?: string;
      key_id?: string;
      notification_template?: string;
      p12_cert?: string;
      team_id?: string;
    };
    Action: {
      name?: string;
      style?: string;
      text?: string;
      type?: string;
      value?: string;
    } | null;
    ActionRequest: {
      name?: string;
      style?: string;
      text?: string;
      type?: string;
      value?: string;
    } | null;
    AnyEvent: { [key: string]: unknown } | null;
    App: {
      async_url_enrich_enabled?: boolean;
      auto_translation_enabled?: boolean;
      before_message_send_hook_url?: string;
      campaign_enabled?: boolean;
      channel_configs?: {
        [key: string]: components['schemas']['ChannelConfig'];
      };
      custom_action_handler_url?: string;
      disable_auth_checks?: boolean;
      disable_permissions_checks?: boolean;
      enforce_unique_usernames?: string;
      file_upload_config?: components['schemas']['FileUploadConfig'];
      grants?: { [key: string]: string[] };
      image_moderation_enabled?: boolean;
      image_moderation_labels?: string[];
      image_upload_config?: components['schemas']['FileUploadConfig'];
      multi_tenant_enabled?: boolean;
      name?: string;
      organization?: string;
      permission_version?: string;
      policies?: { [key: string]: components['schemas']['Policy'][] };
      push_notifications?: components['schemas']['PushNotificationFields'];
      revoke_tokens_issued_before?: string;
      search_backend?: string;
      sqs_key?: string;
      sqs_secret?: string;
      sqs_url?: string;
      suspended?: boolean;
      suspended_explanation?: string;
      user_search_disallowed_roles?: string[];
      webhook_url?: string;
    };
    Attachment:
      | ({
          actions?: components['schemas']['Action'][];
          asset_url?: string;
          author_icon?: string;
          author_link?: string;
          author_name?: string;
          color?: string;
          fallback?: string;
          fields?: components['schemas']['Field'][];
          footer?: string;
          footer_icon?: string;
          image_url?: string;
          og_scrape_url?: string;
          pretext?: string;
          text?: string;
          thumb_url?: string;
          title?: string;
          title_link?: string;
          /** Attachment type (e.g. image, video, url) */
          type?: string;
        } & { [key: string]: unknown })
      | null;
    AttachmentRequest:
      | ({
          actions?: components['schemas']['ActionRequest'][];
          asset_url?: string;
          author_icon?: string;
          author_link?: string;
          author_name?: string;
          color?: string;
          fallback?: string;
          fields?: components['schemas']['FieldRequest'][];
          footer?: string;
          footer_icon?: string;
          image_url?: string;
          og_scrape_url?: string;
          pretext?: string;
          text?: string;
          thumb_url?: string;
          title?: string;
          title_link?: string;
          /** Attachment type (e.g. image, video, url) */
          type?: string;
        } & { [key: string]: unknown })
      | null;
    BanRequest: {
      /** User who issued a ban */
      banned_by?: components['schemas']['UserObjectRequest'];
      /** User ID who issued a ban */
      banned_by_id?: string;
      /** Channel ID to ban user in */
      id?: string;
      /** Whether to perform IP ban or not */
      ip_ban?: boolean;
      /** Ban reason */
      reason?: string;
      /** Whether to perform shadow ban or not */
      shadow?: boolean;
      /** ID of user to ban */
      target_user_id: string;
      /** Timeout of ban in minutes. User will be unbanned after this period of time */
      timeout?: number;
      /** Channel type to ban user in */
      type?: string;
      /** **Server-side only**. User object which server acts upon */
      user?: components['schemas']['UserObjectRequest'];
      /** **Server-side only**. User ID which server acts upon */
      user_id?: string;
    } | null;
    BanResponse: {
      banned_by?: components['schemas']['UserObject'];
      channel?: components['schemas']['ChannelResponse'];
      created_at?: string;
      expires?: string;
      reason?: string;
      shadow?: boolean;
      user?: components['schemas']['UserObject'];
    } | null;
    /** Block list contains restricted words */
    BlockList: {
      /** Date/time of creation */
      created_at?: string;
      /** Block list name */
      name?: string;
      /** Date/time of the last update */
      updated_at?: string;
      /** List of words to block */
      words?: string[];
    };
    Campaign: {
      attachments?: components['schemas']['Attachment'][];
      channel_type: string;
      completed_at?: string;
      created_at?: string;
      defaults?: { [key: string]: string };
      deleted_at?: string;
      description?: string;
      failed_at?: string;
      filter?: components['schemas']['SegmentFilter'];
      id?: string;
      name: string;
      progress?: number;
      push_notifications?: boolean;
      resumed_at?: string;
      scheduled_at?: string;
      segment_id: string;
      sender_id: string;
      status?: string;
      stopped_at?: string;
      text: string;
      updated_at?: string;
    };
    CampaignDataRequest: {
      attachments?: components['schemas']['AttachmentRequest'][];
      channel_type: string;
      defaults?: { [key: string]: string };
      description?: string;
      filter?: components['schemas']['SegmentFilterRequest'];
      name: string;
      push_notifications?: boolean;
      segment_id: string;
      sender_id: string;
      text: string;
    };
    CampaignUpdateableFieldsRequest: {
      attachments?: components['schemas']['AttachmentRequest'][];
      channel_type?: string;
      defaults?: { [key: string]: string };
      description?: string;
      name?: string;
      push_notifications?: boolean;
      segment_id?: string;
      sender_id?: string;
      text?: string;
    };
    ChannelConfig: {
      /** Enables automatic message moderation */
      automod: 'disabled' | 'simple' | 'AI';
      /** Sets behavior of automatic moderation */
      automod_behavior?: 'flag' | 'block';
      automod_thresholds?: components['schemas']['Thresholds'];
      /** Name of the blocklist to use */
      blocklist?: string;
      /** Sets behavior of blocklist */
      blocklist_behavior?: 'flag' | 'block';
      /** List of commands that channel supports */
      commands?: string[];
      /** Connect events support */
      connect_events?: boolean;
      /** Date/time of creation */
      created_at?: string;
      /** Enables custom events */
      custom_events?: boolean;
      /** Number of maximum message characters */
      max_message_length?: number;
      /** Number of days to keep messages. 'infinite' disables retention */
      message_retention?: string;
      /** Enables mutes */
      mutes?: boolean;
      /** Channel type name */
      name?: string;
      /** Enables push notifications */
      push_notifications?: boolean;
      /** Enables message reactions */
      reactions?: boolean;
      /** Read events support */
      read_events?: boolean;
      /** Enables message replies (threads) */
      replies?: boolean;
      /** Enables message search */
      search?: boolean;
      /** Typing events support */
      typing_events?: boolean;
      /** Date/time of the last update */
      updated_at?: string;
      /** Enables file uploads */
      uploads?: boolean;
      /** Enables URL enrichment */
      url_enrichment?: boolean;
    } | null;
    /** Channel configuration overrides */
    ChannelConfigRequest: {
      blocklist?: string;
      blocklist_behavior?: 'flag' | 'block';
      grants?: { [key: string]: string[] };
      /** Overrides max message length */
      max_message_length?: number;
      /** Enables or disables reactions */
      reactions?: boolean;
      replies?: boolean;
      /** Enables or disables typing events */
      typing_events?: boolean;
      /** Enables or disables file uploads */
      uploads?: boolean;
      /** Enables or disables URL enrichment */
      url_enrichment?: boolean;
    };
    ChannelConfigWithInfo: {
      /** Enables automatic message moderation */
      automod: 'disabled' | 'simple' | 'AI';
      /** Sets behavior of automatic moderation */
      automod_behavior?: 'flag' | 'block';
      automod_thresholds?: components['schemas']['Thresholds'];
      /** Name of the blocklist to use */
      blocklist?: string;
      /** Sets behavior of blocklist */
      blocklist_behavior?: 'flag' | 'block';
      /** List of commands that channel supports */
      commands?: components['schemas']['Command'][];
      /** Connect events support */
      connect_events?: boolean;
      /** Date/time of creation */
      created_at?: string;
      /** Enables custom events */
      custom_events?: boolean;
      grants?: { [key: string]: string[] };
      /** Number of maximum message characters */
      max_message_length?: number;
      /** Number of days to keep messages. 'infinite' disables retention */
      message_retention?: string;
      /** Enables mutes */
      mutes?: boolean;
      /** Channel type name */
      name?: string;
      /** Enables push notifications */
      push_notifications?: boolean;
      /** Enables message reactions */
      reactions?: boolean;
      /** Read events support */
      read_events?: boolean;
      /** Enables message replies (threads) */
      replies?: boolean;
      /** Enables message search */
      search?: boolean;
      /** Typing events support */
      typing_events?: boolean;
      /** Date/time of the last update */
      updated_at?: string;
      /** Enables file uploads */
      uploads?: boolean;
      /** Enables URL enrichment */
      url_enrichment?: boolean;
    };
    ChannelConfigWithInfoRequest: {
      /** Enables automatic message moderation */
      automod: 'disabled' | 'simple' | 'AI';
      /** Sets behavior of automatic moderation */
      automod_behavior?: 'flag' | 'block';
      automod_thresholds?: components['schemas']['ThresholdsRequest'];
      /** Name of the blocklist to use */
      blocklist?: string;
      /** Sets behavior of blocklist */
      blocklist_behavior?: 'flag' | 'block';
      /** List of commands that channel supports */
      commands?: components['schemas']['CommandRequest'][];
      /** Connect events support */
      connect_events?: boolean;
      /** Date/time of creation */
      created_at?: string;
      /** Enables custom events */
      custom_events?: boolean;
      grants?: { [key: string]: string[] };
      /** Number of maximum message characters */
      max_message_length?: number;
      /** Number of days to keep messages. 'infinite' disables retention */
      message_retention?: string;
      /** Enables mutes */
      mutes?: boolean;
      /** Channel type name */
      name?: string;
      /** Enables push notifications */
      push_notifications?: boolean;
      /** Enables message reactions */
      reactions?: boolean;
      /** Read events support */
      read_events?: boolean;
      /** Enables message replies (threads) */
      replies?: boolean;
      /** Enables message search */
      search?: boolean;
      /** Typing events support */
      typing_events?: boolean;
      /** Date/time of the last update */
      updated_at?: string;
      /** Enables file uploads */
      uploads?: boolean;
      /** Enables URL enrichment */
      url_enrichment?: boolean;
    };
    ChannelCreatedEvent: {
      created_at?: string;
      type: string;
    } | null;
    ChannelDeletedEvent: {
      channel?: components['schemas']['ChannelResponse'];
      channel_id?: string;
      channel_type?: string;
      cid?: string;
      created_at?: string;
      team?: string;
      type: string;
    } | null;
    ChannelExportRequest: {
      /** Channel ID */
      id: string;
      /** Date to export messages since */
      messages_since?: string;
      /** Date to export messages until */
      messages_until?: string;
      /** Channel type */
      type: string;
    };
    ChannelGetOrCreateRequest: {
      /** Websocket connection ID to interact with. You can pass it as body or URL parameter */
      connection_id?: string;
      data?: components['schemas']['ChannelRequest'];
      members?: components['schemas']['PaginationParamsRequest'];
      messages?: components['schemas']['MessagePaginationParamsRequest'];
      /** Fetch user presence info */
      presence?: boolean;
      /** Refresh channel state */
      state?: boolean;
      /** Start watching the channel */
      watch?: boolean;
      watchers?: components['schemas']['PaginationParamsRequest'];
    } | null;
    ChannelHiddenEvent: {
      channel?: components['schemas']['ChannelResponse'];
      channel_id?: string;
      channel_type?: string;
      cid?: string;
      clear_history?: boolean;
      created_at?: string;
      type: string;
      user?: components['schemas']['UserObject'];
    } | null;
    ChannelMember: {
      /** Expiration date of the ban */
      ban_expires?: string;
      /** Whether member is banned this channel or not */
      banned?: boolean;
      /** Role of the member in the channel */
      channel_role?: string;
      /** Date/time of creation */
      created_at?: string;
      /** Date when invite was accepted */
      invite_accepted_at?: string;
      /** Date when invite was rejected */
      invite_rejected_at?: string;
      /** Whether member was invited or not */
      invited?: boolean;
      /** Whether member is channel moderator or not */
      is_moderator?: boolean;
      /** Permission level of the member in the channel (DEPRECATED: use channel_role instead) */
      role?: 'member' | 'moderator' | 'admin' | 'owner';
      /** Whether member is shadow banned in this channel or not */
      shadow_banned?: boolean;
      /** Date/time of the last update */
      updated_at?: string;
      user?: components['schemas']['UserObject'];
      user_id?: string;
    } | null;
    ChannelMemberRequest: {
      /** Expiration date of the ban */
      ban_expires?: string;
      /** Whether member is banned this channel or not */
      banned?: boolean;
      /** Role of the member in the channel */
      channel_role?: string;
      /** Date/time of creation */
      created_at?: string;
      /** Date when invite was accepted */
      invite_accepted_at?: string;
      /** Date when invite was rejected */
      invite_rejected_at?: string;
      /** Whether member was invited or not */
      invited?: boolean;
      /** Whether member is channel moderator or not */
      is_moderator?: boolean;
      /** Permission level of the member in the channel (DEPRECATED: use channel_role instead) */
      role?: 'member' | 'moderator' | 'admin' | 'owner';
      /** Whether member is shadow banned in this channel or not */
      shadow_banned?: boolean;
      /** Date/time of the last update */
      updated_at?: string;
      user?: components['schemas']['UserObjectRequest'];
      user_id?: string;
    } | null;
    ChannelMute: {
      channel?: components['schemas']['ChannelResponse'];
      /** Date/time of creation */
      created_at?: string;
      /** Date/time of mute expiration */
      expires?: string;
      /** Date/time of the last update */
      updated_at?: string;
      /** Owner of channel mute */
      user?: components['schemas']['UserObject'];
    } | null;
    ChannelMuteRequest: {
      channel?: components['schemas']['ChannelResponseRequest'];
      /** Date/time of creation */
      created_at?: string;
      /** Date/time of mute expiration */
      expires?: string;
      /** Date/time of the last update */
      updated_at?: string;
      /** Owner of channel mute */
      user?: components['schemas']['UserObjectRequest'];
    } | null;
    ChannelMutedEvent: {
      created_at?: string;
      type: string;
    } | null;
    ChannelRequest: {
      /** Enable or disable auto translation */
      auto_translation_enabled?: boolean;
      /** Switch auto translation language */
      auto_translation_language?: string;
      config_overrides?: components['schemas']['ChannelConfigRequest'];
      created_by?: components['schemas']['UserObjectRequest'];
      disabled?: boolean;
      /** Freeze or unfreeze the channel */
      frozen?: boolean;
      members?: components['schemas']['ChannelMemberRequest'][];
      own_capabilities?: number[];
      /** Team the channel belongs to (if multi-tenant mode is enabled) */
      team?: string;
    } & { [key: string]: unknown };
    /** Represents channel in chat */
    ChannelResponse: {
      /** Whether auto translation is enabled or not */
      auto_translation_enabled?: boolean;
      /** Language to translate to when auto translation is active */
      auto_translation_language?: string;
      /** Channel CID (<type>:<id>) */
      cid?: string;
      /** Channel configuration */
      config?: components['schemas']['ChannelConfigWithInfo'];
      /** Cooldown period after sending each message */
      cooldown?: number;
      /** Date/time of creation */
      created_at?: string;
      /** Creator of the channel */
      created_by?: components['schemas']['UserObject'];
      /** Date/time of deletion */
      deleted_at?: string;
      disabled?: boolean;
      /** Whether channel is frozen or not */
      frozen?: boolean;
      /** Whether this channel is hidden by current user or not */
      hidden?: boolean;
      /** Date since when the message history is accessible */
      hide_messages_before?: string;
      /** Channel unique ID */
      id?: string;
      /** Date of the last message sent */
      last_message_at?: string;
      /** Number of members in the channel */
      member_count?: number;
      /** List of channel members (max 100) */
      members?: components['schemas']['ChannelMember'][];
      /** Date of mute expiration */
      mute_expires_at?: string;
      /** Whether this channel is muted or not */
      muted?: boolean;
      /** List of channel capabilities of authenticated user */
      own_capabilities?: string[];
      /** Team the channel belongs to (multi-tenant only) */
      team?: string;
      /** Type of the channel */
      type?: string;
      /** Date/time of the last update */
      updated_at?: string;
    } & { [key: string]: unknown };
    /** Represents channel in chat */
    ChannelResponseRequest: {
      /** Whether auto translation is enabled or not */
      auto_translation_enabled?: boolean;
      /** Language to translate to when auto translation is active */
      auto_translation_language?: string;
      /** Channel CID (<type>:<id>) */
      cid?: string;
      /** Channel configuration */
      config?: components['schemas']['ChannelConfigWithInfoRequest'];
      /** Cooldown period after sending each message */
      cooldown?: number;
      /** Date/time of creation */
      created_at?: string;
      /** Creator of the channel */
      created_by?: components['schemas']['UserObjectRequest'];
      /** Date/time of deletion */
      deleted_at?: string;
      disabled?: boolean;
      /** Whether channel is frozen or not */
      frozen?: boolean;
      /** Whether this channel is hidden by current user or not */
      hidden?: boolean;
      /** Date since when the message history is accessible */
      hide_messages_before?: string;
      /** Channel unique ID */
      id?: string;
      /** Date of the last message sent */
      last_message_at?: string;
      /** Number of members in the channel */
      member_count?: number;
      /** List of channel members (max 100) */
      members?: components['schemas']['ChannelMemberRequest'][];
      /** Date of mute expiration */
      mute_expires_at?: string;
      /** Whether this channel is muted or not */
      muted?: boolean;
      /** List of channel capabilities of authenticated user */
      own_capabilities?: string[];
      /** Team the channel belongs to (multi-tenant only) */
      team?: string;
      /** Type of the channel */
      type?: string;
      /** Date/time of the last update */
      updated_at?: string;
    } & { [key: string]: unknown };
    ChannelStateResponse: {
      channel?: components['schemas']['ChannelResponse'];
      /** Duration of the request in human-readable format */
      duration?: string;
      /** Whether this channel is hidden or not */
      hidden?: boolean;
      /** Messages before this date are hidden from the user */
      hide_messages_before?: string;
      /** List of channel members */
      members?: components['schemas']['ChannelMember'][];
      /** Current user membership object */
      membership?: components['schemas']['ChannelMember'];
      /** List of channel messages */
      messages?: components['schemas']['Message'][];
      /** List of pinned messages in the channel */
      pinned_messages?: components['schemas']['Message'][];
      /** List of read states */
      read?: components['schemas']['Read'][];
      /** Number of channel watchers */
      watcher_count?: number;
      /** List of user who is watching the channel */
      watchers?: components['schemas']['UserObject'][];
    } | null;
    ChannelStateResponseFields: {
      channel?: components['schemas']['ChannelResponse'];
      /** Whether this channel is hidden or not */
      hidden?: boolean;
      /** Messages before this date are hidden from the user */
      hide_messages_before?: string;
      /** List of channel members */
      members?: components['schemas']['ChannelMember'][];
      /** Current user membership object */
      membership?: components['schemas']['ChannelMember'];
      /** List of channel messages */
      messages?: components['schemas']['Message'][];
      /** List of pinned messages in the channel */
      pinned_messages?: components['schemas']['Message'][];
      /** List of read states */
      read?: components['schemas']['Read'][];
      /** Number of channel watchers */
      watcher_count?: number;
      /** List of user who is watching the channel */
      watchers?: components['schemas']['UserObject'][];
    };
    ChannelStopWatchingRequest: {
      /** Websocket connection ID to interact with. You can pass it as body or URL parameter */
      connection_id?: string;
    } | null;
    ChannelTruncatedEvent: {
      channel?: components['schemas']['ChannelResponse'];
      channel_id?: string;
      channel_type?: string;
      cid?: string;
      created_at?: string;
      type: string;
    } | null;
    ChannelTypeConfig: {
      /** Enables automatic message moderation */
      automod: 'disabled' | 'simple' | 'AI';
      /** Sets behavior of automatic moderation */
      automod_behavior?: 'flag' | 'block';
      automod_thresholds?: components['schemas']['Thresholds'];
      /** Name of the blocklist to use */
      blocklist?: string;
      /** Sets behavior of blocklist */
      blocklist_behavior?: 'flag' | 'block';
      /** List of commands that channel supports */
      commands?: components['schemas']['Command'][];
      /** Connect events support */
      connect_events?: boolean;
      /** Date/time of creation */
      created_at?: string;
      /** Enables custom events */
      custom_events?: boolean;
      grants?: { [key: string]: string[] };
      /** Number of maximum message characters */
      max_message_length?: number;
      /** Number of days to keep messages. 'infinite' disables retention */
      message_retention?: string;
      /** Enables mutes */
      mutes?: boolean;
      /** Channel type name */
      name?: string;
      permissions?: components['schemas']['PolicyRequest_1'][];
      /** Enables push notifications */
      push_notifications?: boolean;
      /** Enables message reactions */
      reactions?: boolean;
      /** Read events support */
      read_events?: boolean;
      /** Enables message replies (threads) */
      replies?: boolean;
      /** Enables message search */
      search?: boolean;
      /** Typing events support */
      typing_events?: boolean;
      /** Date/time of the last update */
      updated_at?: string;
      /** Enables file uploads */
      uploads?: boolean;
      /** Enables URL enrichment */
      url_enrichment?: boolean;
    } | null;
    ChannelUnmutedEvent: {
      created_at?: string;
      type: string;
    } | null;
    ChannelUpdatedEvent: {
      channel?: components['schemas']['ChannelResponse'];
      channel_id?: string;
      channel_type?: string;
      cid?: string;
      created_at?: string;
      message?: components['schemas']['Message'];
      team?: string;
      type: string;
      user?: components['schemas']['UserObject'];
    } | null;
    ChannelVisibleEvent: {
      channel_id?: string;
      channel_type?: string;
      cid?: string;
      created_at?: string;
      type: string;
      user?: components['schemas']['UserObject'];
    } | null;
    ChannelsResponse: {
      /** List of channels */
      channels?: components['schemas']['ChannelStateResponseFields'][];
      /** Duration of the request in human-readable format */
      duration?: string;
    } | null;
    CheckPushRequest: {
      /** Push message template for APN */
      apn_template?: string;
      /** Push message data template for Firebase */
      firebase_data_template?: string;
      /** Push message template for Firebase */
      firebase_template?: string;
      /** Message ID to send push notification for */
      message_id?: string;
      /** Don't require existing devices to render templates */
      skip_devices?: boolean;
      /** **Server-side only**. User object which server acts upon */
      user?: components['schemas']['UserObjectRequest'];
      /** **Server-side only**. User ID which server acts upon */
      user_id?: string;
    } | null;
    CheckPushResponse: {
      /** Object with device errors */
      device_errors?: {
        [key: string]: components['schemas']['DeviceErrorInfo'];
      };
      /** Duration of the request in human-readable format */
      duration?: string;
      /** List of general errors */
      general_errors?: string[];
      rendered_apn_template?: string;
      rendered_firebase_template?: string;
      rendered_message?: { [key: string]: string };
      /** Don't require existing devices to render templates */
      skip_devices?: boolean;
    } | null;
    CheckSQSRequest: {
      /** AWS SQS access key */
      sqs_key?: string;
      /** AWS SQS key secret */
      sqs_secret?: string;
      /** AWS SQS endpoint URL */
      sqs_url?: string;
    } | null;
    CheckSQSResponse: {
      /** Error data */
      data?: { [key: string]: unknown };
      /** Duration of the request in human-readable format */
      duration?: string;
      /** Error text */
      error?: string;
      /** Validation result */
      status?: 'ok' | 'error';
    } | null;
    /** Represents custom chat command */
    Command: {
      /** Arguments help text, shown in commands auto-completion */
      args?: string;
      /** Date/time of creation */
      created_at?: string;
      /** Description, shown in commands auto-completion */
      description?: string;
      /** Unique command name */
      name?: string;
      /** Set name used for grouping commands */
      set?: string;
      /** Date/time of the last update */
      updated_at?: string;
    } | null;
    /** Represents custom chat command */
    CommandRequest: {
      /** Arguments help text, shown in commands auto-completion */
      args?: string;
      /** Description, shown in commands auto-completion */
      description?: string;
      /** Unique command name */
      name?: string;
      /** Set name used for grouping commands */
      set?: string;
    } | null;
    ConnectRequest: {
      device?: components['schemas']['DeviceFields'];
      user_details: components['schemas']['UserObject'];
    };
    /** Block list contains restricted words */
    CreateBlockListRequest: {
      /** Block list name */
      name: string;
      /** List of words to block */
      words: string[];
    } | null;
    CreateCampaignRequest: {
      campaign: components['schemas']['CampaignDataRequest'];
    } | null;
    CreateCampaignResponse: {
      campaign?: components['schemas']['Campaign'];
      /** Duration of the request in human-readable format */
      duration?: string;
    } | null;
    CreateChannelTypeRequest: {
      /** Enables automatic message moderation */
      automod: 'disabled' | 'simple' | 'AI';
      /** Sets behavior of automatic moderation */
      automod_behavior?: 'flag' | 'block';
      /** Name of the blocklist to use */
      blocklist?: string;
      /** Sets behavior of blocklist */
      blocklist_behavior?: 'flag' | 'block';
      /** List of commands that channel supports */
      commands?: string[];
      /** Connect events support */
      connect_events?: boolean;
      /** Enables custom events */
      custom_events?: boolean;
      grants?: { [key: string]: string[] };
      /** Number of maximum message characters */
      max_message_length?: number;
      /** Number of days to keep messages. 'infinite' disables retention */
      message_retention?: string;
      /** Enables mutes */
      mutes?: boolean;
      /** Channel type name */
      name: string;
      /** List of permissions for the channel type */
      permissions?: components['schemas']['PolicyRequest'][];
      /** Enables push notifications */
      push_notifications?: boolean;
      /** Enables message reactions */
      reactions?: boolean;
      /** Read events support */
      read_events?: boolean;
      /** Enables message replies (threads) */
      replies?: boolean;
      /** Enables message search */
      search?: boolean;
      /** Typing events support */
      typing_events?: boolean;
      /** Enables file uploads */
      uploads?: boolean;
      /** Enables URL enrichment */
      url_enrichment?: boolean;
    } | null;
    CreateChannelTypeResponse: {
      /** Enables automatic message moderation */
      automod: 'disabled' | 'simple' | 'AI';
      /** Sets behavior of automatic moderation */
      automod_behavior?: 'flag' | 'block';
      automod_thresholds?: components['schemas']['Thresholds'];
      /** Name of the blocklist to use */
      blocklist?: string;
      /** Sets behavior of blocklist */
      blocklist_behavior?: 'flag' | 'block';
      /** List of commands that channel supports */
      commands?: string[];
      /** Connect events support */
      connect_events?: boolean;
      /** Date/time of creation */
      created_at?: string;
      /** Enables custom events */
      custom_events?: boolean;
      /** Duration of the request in human-readable format */
      duration?: string;
      grants?: { [key: string]: string[] };
      /** Number of maximum message characters */
      max_message_length?: number;
      /** Number of days to keep messages. 'infinite' disables retention */
      message_retention?: string;
      /** Enables mutes */
      mutes?: boolean;
      /** Channel type name */
      name?: string;
      permissions?: components['schemas']['PolicyRequest_1'][];
      /** Enables push notifications */
      push_notifications?: boolean;
      /** Enables message reactions */
      reactions?: boolean;
      /** Read events support */
      read_events?: boolean;
      /** Enables message replies (threads) */
      replies?: boolean;
      /** Enables message search */
      search?: boolean;
      /** Typing events support */
      typing_events?: boolean;
      /** Date/time of the last update */
      updated_at?: string;
      /** Enables file uploads */
      uploads?: boolean;
      /** Enables URL enrichment */
      url_enrichment?: boolean;
    } | null;
    /** Represents custom chat command */
    CreateCommandRequest: {
      /** Arguments help text, shown in commands auto-completion */
      args?: string;
      /** Description, shown in commands auto-completion */
      description: string;
      /** Unique command name */
      name: string;
      /** Set name used for grouping commands */
      set?: string;
    } | null;
    CreateCommandResponse: {
      command?: components['schemas']['Command'];
      /** Duration of the request in human-readable format */
      duration?: string;
    } | null;
    CreateDeviceRequest: {
      id?: string;
      push_provider?: 'firebase' | 'apn' | 'huawei';
      /** **Server-side only**. User object which server acts upon */
      user?: components['schemas']['UserObjectRequest'];
      /** **Server-side only**. User ID which server acts upon */
      user_id?: string;
    } | null;
    CreateRoleRequest: {
      /** Role name */
      name: string;
    } | null;
    CreateRoleResponse: {
      /** Duration of the request in human-readable format */
      duration?: string;
      role?: components['schemas']['Role'];
    } | null;
    CreateSegmentRequest: {
      segment: components['schemas']['SegmentDataRequest'];
    } | null;
    CreateSegmentResponse: {
      /** Duration of the request in human-readable format */
      duration?: string;
      segment?: components['schemas']['Segment'];
    } | null;
    DeactivateUserRequest: {
      /** **Server-side only**. ID of user who deactivated the user */
      created_by_id?: string;
      /** Makes messages appear to be deleted */
      mark_messages_deleted?: boolean;
      user_id: string;
    } | null;
    DeactivateUserResponse: {
      /** Duration of the request in human-readable format */
      duration?: string;
      user?: components['schemas']['UserObject'];
    } | null;
    DeleteCampaignResponse: {
      /** Duration of the request in human-readable format */
      duration?: string;
    } | null;
    DeleteChannelResponse: {
      channel?: components['schemas']['ChannelResponse'];
      /** Duration of the request in human-readable format */
      duration?: string;
    } | null;
    DeleteChannelsRequest: {
      cids?: string[];
      hard_delete?: boolean;
    } | null;
    DeleteChannelsResponse: {
      /** Duration of the request in human-readable format */
      duration?: string;
      result?: { [key: string]: components['schemas']['DeleteChannelsResult'] };
      task_id?: string;
    } | null;
    DeleteChannelsResult: {
      error?: string;
      status?: string;
    } | null;
    DeleteCommandResponse: {
      /** Duration of the request in human-readable format */
      duration?: string;
      name?: string;
    } | null;
    DeleteSegmentResponse: {
      /** Duration of the request in human-readable format */
      duration?: string;
    } | null;
    DeleteUserResponse: {
      /** Duration of the request in human-readable format */
      duration?: string;
      user?: components['schemas']['UserObject'];
    } | null;
    Device: {
      /** Date/time of creation */
      created_at?: string;
      /** Whether device is disabled or not */
      disabled?: boolean;
      /** Reason explaining why device had been disabled */
      disabled_reason?: string;
      /** Device ID */
      id?: string;
      push_provider?: 'firebase' | 'apn' | 'huawei';
      user_id?: string;
    } | null;
    DeviceErrorInfo: {
      error_message?: string;
      provider?: string;
    };
    DeviceFields: {
      /** Device ID */
      id?: string;
      push_provider?: 'firebase' | 'apn' | 'huawei';
    };
    DeviceRequest: {
      /** Date/time of creation */
      created_at?: string;
      /** Whether device is disabled or not */
      disabled?: boolean;
      /** Reason explaining why device had been disabled */
      disabled_reason?: string;
      /** Device ID */
      id?: string;
      push_provider?: 'firebase' | 'apn' | 'huawei';
      user_id?: string;
    } | null;
    ErrorResult: {
      description?: unknown;
      stacktrace?: string;
      type?: string;
      version?: string;
    };
    /** Represents an event that happened in Stream Chat */
    Event: {
      /** Only applicable to `message.flagged` event. */
      automoderation?: boolean;
      /** Only applicable to `message.flagged` event. */
      automoderation_scores?: components['schemas']['ModerationResponse'];
      channel?: components['schemas']['ChannelResponse'];
      channel_id?: string;
      channel_type?: string;
      /** Channel CID (<type>:<id>) */
      cid?: string;
      /** Only applicable to `health.check` event */
      connection_id?: string;
      /** Date/time of creation */
      created_at?: string;
      /** User who issued moderation action. Only applicable to moderation-related events */
      created_by?: components['schemas']['UserObject'];
      me?: components['schemas']['OwnUser'];
      member?: components['schemas']['ChannelMember'];
      message?: components['schemas']['Message'];
      /** ID of thread. Used in typing events */
      parent_id?: string;
      reaction?: components['schemas']['Reaction'];
      /** Ban reason. Only applicable to `user.banned` event */
      reason?: string;
      team?: string;
      /** Event type. To use custom event types see Custom Events documentation */
      type: string;
      user?: components['schemas']['UserObject'];
      user_id?: string;
      /** Number of watchers who received this event */
      watcher_count?: number;
    } & { [key: string]: unknown };
    /** Represents an event that happened in Stream Chat */
    EventRequest: {
      /** Only applicable to `message.flagged` event. */
      automoderation?: boolean;
      /** Only applicable to `message.flagged` event. */
      automoderation_scores?: components['schemas']['ModerationResponseRequest'];
      channel?: components['schemas']['ChannelResponseRequest'];
      channel_id?: string;
      channel_type?: string;
      /** Channel CID (<type>:<id>) */
      cid?: string;
      /** Only applicable to `health.check` event */
      connection_id?: string;
      /** Date/time of creation */
      created_at?: string;
      /** User who issued moderation action. Only applicable to moderation-related events */
      created_by?: components['schemas']['UserObjectRequest'];
      me?: components['schemas']['OwnUserRequest'];
      member?: components['schemas']['ChannelMemberRequest'];
      message?: components['schemas']['MessageRequest_1'];
      /** ID of thread. Used in typing events */
      parent_id?: string;
      reaction?: components['schemas']['ReactionRequest'];
      /** Ban reason. Only applicable to `user.banned` event */
      reason?: string;
      team?: string;
      /** Event type. To use custom event types see Custom Events documentation */
      type: string;
      user?: components['schemas']['UserObjectRequest'];
      user_id?: string;
      /** Number of watchers who received this event */
      watcher_count?: number;
    } & { [key: string]: unknown };
    EventResponse: {
      /** Duration of the request in human-readable format */
      duration?: string;
      event?: components['schemas']['Event'];
    } | null;
    ExportChannelsRequest: {
      /** Export options for channels */
      channels?: components['schemas']['ChannelExportRequest'][];
      /** Set if deleted message text should be cleared */
      clear_deleted_message_text?: boolean;
      /** Set if you want to include truncated messages */
      include_truncated_messages?: boolean;
    } | null;
    ExportChannelsResponse: {
      /** Duration of the request in human-readable format */
      duration?: string;
      task_id?: string;
    } | null;
    ExportChannelsResult: {
      /** S3 path of result */
      path?: string;
      /** S3 bucket name result */
      s3_bucket_name?: string;
      /** URL of result */
      url?: string;
    };
    ExportUserResponse: {
      /** Duration of the request in human-readable format */
      duration?: string;
      messages?: components['schemas']['Message'][];
      reactions?: components['schemas']['Reaction'][];
      user?: components['schemas']['UserObject'];
    } | null;
    Field: {
      short?: boolean;
      title?: string;
      value?: string;
    } | null;
    FieldRequest: {
      short?: boolean;
      title?: string;
      value?: string;
    } | null;
    FileDeleteResponse: {
      /** Duration of the request in human-readable format */
      duration?: string;
    } | null;
    FileUploadConfig: {
      allowed_file_extensions?: string[];
      allowed_mime_types?: string[];
      blocked_file_extensions?: string[];
      blocked_mime_types?: string[];
    };
    FileUploadConfigRequest: {
      allowed_file_extensions?: string[];
      allowed_mime_types?: string[];
      blocked_file_extensions?: string[];
      blocked_mime_types?: string[];
    };
    FileUploadRequest: {
      /** multipart/form-data file field */
      file?: string;
    } | null;
    FileUploadResponse: {
      /** Duration of the request in human-readable format */
      duration?: string;
      file?: string;
    } | null;
    FirebaseConfigFields: {
      data_template?: string;
      enabled?: boolean;
      notification_template?: string;
    };
    FirebaseConfigRequest: {
      credentials_json?: string;
      data_template?: string;
      notification_template?: string;
      server_key?: string;
    };
    /** Contains information about flagged user or message */
    Flag: {
      /** Date of the approval */
      approved_at?: string;
      /** Date/time of creation */
      created_at?: string;
      created_by_automod?: boolean;
      /** Date of the rejection */
      rejected_at?: string;
      /** Date of the review */
      reviewed_at?: string;
      /** ID of flagged message */
      target_message_id?: string;
      /** Flagged user */
      target_user?: components['schemas']['UserObject'];
      /** Date/time of the last update */
      updated_at?: string;
      /** User who flagged a message or a user */
      user?: components['schemas']['UserObject'];
    };
    FlagRequest: {
      /** ID of the message when reporting a message */
      target_message_id?: string;
      /** ID of the user when reporting a user */
      target_user_id?: string;
      /** **Server-side only**. User object which server acts upon */
      user?: components['schemas']['UserObjectRequest'];
      /** **Server-side only**. User ID which server acts upon */
      user_id?: string;
    } | null;
    FlagResponse: {
      /** Duration of the request in human-readable format */
      duration?: string;
      flag?: components['schemas']['Flag'];
    } | null;
    GetApplicationResponse: {
      app?: components['schemas']['App'];
      /** Duration of the request in human-readable format */
      duration?: string;
    } | null;
    GetBlockListResponse: {
      blocklist?: components['schemas']['BlockList'];
      /** Duration of the request in human-readable format */
      duration?: string;
    } | null;
    GetCampaignResponse: {
      campaign?: components['schemas']['Campaign'];
      /** Duration of the request in human-readable format */
      duration?: string;
    } | null;
    GetCommandResponse: {
      /** Arguments help text, shown in commands auto-completion */
      args?: string;
      /** Date/time of creation */
      created_at?: string;
      /** Description, shown in commands auto-completion */
      description?: string;
      /** Duration of the request in human-readable format */
      duration?: string;
      /** Unique command name */
      name?: string;
      /** Set name used for grouping commands */
      set?: string;
      /** Date/time of the last update */
      updated_at?: string;
    } | null;
    GetCustomPermissionResponse: {
      /** Duration of the request in human-readable format */
      duration?: string;
      permission?: components['schemas']['Permission'];
    } | null;
    GetExportChannelsStatusResponse: {
      /** Date/time of creation */
      created_at?: string;
      /** Duration of the request in human-readable format */
      duration?: string;
      /** Contains task error in case of failure */
      error?: components['schemas']['ErrorResult'];
      /** Contains task result in case of success */
      result?: components['schemas']['ExportChannelsResult'];
      /** Task status */
      status?: 'waiting' | 'pending' | 'running' | 'completed' | 'failed';
      task_id?: string;
      /** Date/time of the last update */
      updated_at?: string;
    } | null;
    GetManyMessagesResponse: {
      /** Duration of the request in human-readable format */
      duration?: string;
      /** List of messages */
      messages?: components['schemas']['Message'][];
    } | null;
    GetOGResponse:
      | ({
          actions?: components['schemas']['Action'][];
          asset_url?: string;
          author_icon?: string;
          author_link?: string;
          author_name?: string;
          color?: string;
          /** Duration of the request in human-readable format */
          duration?: string;
          fallback?: string;
          fields?: components['schemas']['Field'][];
          footer?: string;
          footer_icon?: string;
          image_url?: string;
          og_scrape_url?: string;
          pretext?: string;
          text?: string;
          thumb_url?: string;
          title?: string;
          title_link?: string;
          /** Attachment type (e.g. image, video, url) */
          type?: string;
        } & { [key: string]: unknown })
      | null;
    GetRateLimitsResponse: {
      /** Map of endpoint rate limits for the Android platform */
      android?: { [key: string]: components['schemas']['LimitInfo'] };
      /** Duration of the request in human-readable format */
      duration?: string;
      /** Map of endpoint rate limits for the iOS platform */
      ios?: { [key: string]: components['schemas']['LimitInfo'] };
      /** Map of endpoint rate limits for the server-side platform */
      server_side?: { [key: string]: components['schemas']['LimitInfo'] };
      /** Map of endpoint rate limits for the web platform */
      web?: { [key: string]: components['schemas']['LimitInfo'] };
    } | null;
    GetReactionsResponse: {
      /** Duration of the request in human-readable format */
      duration?: string;
      /** List of reactions */
      reactions?: components['schemas']['Reaction'][];
    } | null;
    GetRepliesResponse: {
      /** Duration of the request in human-readable format */
      duration?: string;
      /** List of messages */
      messages?: components['schemas']['Message'][];
    } | null;
    GetSegmentResponse: {
      /** Duration of the request in human-readable format */
      duration?: string;
      segment?: components['schemas']['Segment'];
    } | null;
    GetTaskResponse: {
      /** Date/time of creation */
      created_at?: string;
      /** Duration of the request in human-readable format */
      duration?: string;
      /** Error produced by task */
      error?: components['schemas']['ErrorResult'];
      /** Result produced by task after completion */
      result?: { [key: string]: unknown };
      /** Task status */
      status?: 'waiting' | 'pending' | 'running' | 'completed' | 'failed';
      task_id?: string;
      /** Date/time of the last update */
      updated_at?: string;
    } | null;
    GuestRequest: {
      user: components['schemas']['UserObjectRequest'];
    } | null;
    GuestResponse: {
      /** Authentication token to use for guest user */
      access_token?: string;
      /** Duration of the request in human-readable format */
      duration?: string;
      /** Created user object */
      user?: components['schemas']['UserObject'];
    } | null;
    HealthCheckEvent: {
      cid?: string;
      created_at?: string;
      me?: components['schemas']['OwnUser'];
      type: string;
    };
    HideChannelRequest: {
      /** Whether to clear message history of the channel or not */
      clear_history?: boolean;
      /** **Server-side only**. User object which server acts upon */
      user?: components['schemas']['UserObjectRequest'];
      /** **Server-side only**. User ID which server acts upon */
      user_id?: string;
    } | null;
    HideChannelResponse: {
      /** Duration of the request in human-readable format */
      duration?: string;
    } | null;
    HuaweiConfigFields: {
      enabled?: boolean;
    };
    HuaweiConfigRequest: {
      id?: string;
      secret?: string;
    };
    ImageSize: {
      /** Crop mode */
      crop?: 'top' | 'bottom' | 'left' | 'right' | 'center';
      /** Target image height */
      height?: number;
      /** Resize method */
      resize?: 'clip' | 'crop' | 'scale' | 'fill';
      /** Target image width */
      width?: number;
    };
    ImageSizeRequest: {
      /** Crop mode */
      crop?: 'top' | 'bottom' | 'left' | 'right' | 'center';
      /** Target image height */
      height?: number;
      /** Resize method */
      resize?: 'clip' | 'crop' | 'scale' | 'fill';
      /** Target image width */
      width?: number;
    };
    ImageUploadRequest: {
      /** multipart/form-data file field */
      file?: string;
      /** multipart/form-data field with JSON-encoded array of image size configurations */
      upload_sizes?: components['schemas']['ImageSizeRequest'][];
    } | null;
    ImageUploadResponse: {
      /** Duration of the request in human-readable format */
      duration?: string;
      file?: string;
      upload_sizes?: components['schemas']['ImageSize'][];
    } | null;
    LabelThresholds: {
      /** Threshold for automatic message block */
      block?: number;
      /** Threshold for automatic message flag */
      flag?: number;
    };
    LabelThresholdsRequest: {
      /** Threshold for automatic message block */
      block?: number;
      /** Threshold for automatic message flag */
      flag?: number;
    };
    LimitInfo: {
      /** The maximum number of calls allowed for the time window */
      limit?: number;
      /** The number of remaining calls in the current window */
      remaining?: number;
      /** The Unix timestamp of the next window */
      reset?: number;
    };
    ListBlockListResponse: {
      blocklists?: components['schemas']['BlockList'][];
      /** Duration of the request in human-readable format */
      duration?: string;
    } | null;
    ListCampaignsResponse: {
      campaigns?: components['schemas']['Campaign'][];
      /** Duration of the request in human-readable format */
      duration?: string;
    } | null;
    ListChannelTypesResponse: {
      /** Object with all channel types */
      channel_types?: {
        [key: string]: components['schemas']['ChannelTypeConfig'];
      };
      /** Duration of the request in human-readable format */
      duration?: string;
    } | null;
    ListCommandsResponse: {
      commands?: components['schemas']['Command'][];
      /** Duration of the request in human-readable format */
      duration?: string;
    } | null;
    ListDevicesResponse: {
      /** List of devices */
      devices?: components['schemas']['Device'][];
      /** Duration of the request in human-readable format */
      duration?: string;
    } | null;
    ListPermissionsResponse: {
      /** Duration of the request in human-readable format */
      duration?: string;
      permissions?: components['schemas']['Permission'][];
    } | null;
    ListRolesResponse: {
      /** Duration of the request in human-readable format */
      duration?: string;
      roles?: components['schemas']['Role'][];
    } | null;
    ListSegmentsResponse: {
      /** Duration of the request in human-readable format */
      duration?: string;
      segments?: components['schemas']['Segment'][];
    } | null;
    MarkReadAllRequest: {
      /** **Server-side only**. User object which server acts upon */
      user?: components['schemas']['UserObjectRequest'];
      /** **Server-side only**. User ID which server acts upon */
      user_id?: string;
    } | null;
    MarkReadRequest: {
      /** ID of the message that is considered last read by client */
      message_id?: string;
      /** **Server-side only**. User object which server acts upon */
      user?: components['schemas']['UserObjectRequest'];
      /** **Server-side only**. User ID which server acts upon */
      user_id?: string;
    } | null;
    MarkReadResponse: {
      /** Duration of the request in human-readable format */
      duration?: string;
      /** Mark read event */
      event?: components['schemas']['Event'];
    } | null;
    MemberAddedEvent: {
      channel_id?: string;
      channel_type?: string;
      cid?: string;
      created_at?: string;
      member?: components['schemas']['ChannelMember'];
      team?: string;
      type: string;
      user?: components['schemas']['UserObject'];
    } | null;
    MemberRemovedEvent: {
      channel_id?: string;
      channel_type?: string;
      cid?: string;
      created_at?: string;
      member?: components['schemas']['ChannelMember'];
      type: string;
      user?: components['schemas']['UserObject'];
    } | null;
    MemberUpdatedEvent: {
      channel_id?: string;
      channel_type?: string;
      cid?: string;
      created_at?: string;
      member?: components['schemas']['ChannelMember'];
      team?: string;
      type: string;
      user?: components['schemas']['UserObject'];
    } | null;
    MembersResponse: {
      /** Duration of the request in human-readable format */
      duration?: string;
      /** List of found members */
      members?: components['schemas']['ChannelMember'][];
    } | null;
    /** Represents any chat message */
    Message:
      | ({
          /** Array of message attachments */
          attachments?: components['schemas']['Attachment'][];
          /** Whether `before_message_send webhook` failed or not. Field is only accessible in push webhook */
          before_message_send_failed?: boolean;
          /** Channel unique identifier in <type>:<id> format */
          cid?: string;
          /** Contains provided slash command */
          command?: string;
          /** Date/time of creation */
          created_at?: string;
          /** Date/time of deletion */
          deleted_at?: string;
          /** Contains HTML markup of the message */
          html?: string;
          /** Object with translations. Key `language` contains the original language key. Other keys contain translations */
          i18n?: { [key: string]: string };
          /** Message ID is unique string identifier of the message */
          id?: string;
          /** Contains image moderation information */
          image_labels?: { [key: string]: string[] };
          /** List of 10 latest reactions to this message */
          latest_reactions?: components['schemas']['Reaction'][];
          /** List of mentioned users */
          mentioned_users?: components['schemas']['UserObject'][];
          /** Should be empty if `text` is provided */
          mml: string;
          /** List of 10 latest reactions of authenticated user to this message */
          own_reactions?: components['schemas']['Reaction'][];
          /** ID of parent message (thread) */
          parent_id?: string;
          /** Date when pinned message expires */
          pin_expires?: string;
          /** Whether message is pinned or not */
          pinned?: boolean;
          /** Date when message got pinned */
          pinned_at?: string;
          /** Contains user who pinned the message */
          pinned_by?: components['schemas']['UserObject'];
          /** Contains quoted message */
          quoted_message?: components['schemas']['Message'];
          quoted_message_id?: string;
          /** An object containing number of reactions of each type. Key: reaction type (string), value: number of reactions (int) */
          reaction_counts?: { [key: string]: number };
          /** An object containing scores of reactions of each type. Key: reaction type (string), value: total score of reactions (int) */
          reaction_scores?: { [key: string]: number };
          /** Number of replies to this message */
          reply_count?: number;
          /** Whether the message was shadowed or not */
          shadowed?: boolean;
          /** Whether thread reply should be shown in the channel as well */
          show_in_channel?: boolean;
          /** Whether message is silent or not */
          silent?: boolean;
          /** Text of the message. Should be empty if `mml` is provided */
          text: string;
          /** List of users who participate in thread */
          thread_participants?: components['schemas']['UserObject'][];
          /** Contains type of the message */
          type?: 'regular' | 'ephemeral' | 'error' | 'reply' | 'system' | 'deleted';
          /** Date/time of the last update */
          updated_at?: string;
          /** Sender of the message. Required when using server-side API */
          user?: components['schemas']['UserObject'];
        } & { [key: string]: unknown })
      | null;
    MessageActionRequest: {
      /** Data to execute command with */
      form_data: { [key: string]: string };
      /** **Server-side only**. User object which server acts upon */
      user?: components['schemas']['UserObjectRequest'];
      /** **Server-side only**. User ID which server acts upon */
      user_id?: string;
    } | null;
    MessageDeletedEvent: {
      channel_id?: string;
      channel_type?: string;
      cid?: string;
      created_at?: string;
      hard_delete?: boolean;
      message?: components['schemas']['Message'];
      team?: string;
      type: string;
      user?: components['schemas']['UserObject'];
    } | null;
    MessageFlag: {
      approved_at?: string;
      created_at?: string;
      created_by_automod?: boolean;
      message?: components['schemas']['Message'];
      moderation_result?: components['schemas']['MessageModerationResult'];
      rejected_at?: string;
      reviewed_at?: string;
      reviewed_by?: components['schemas']['UserObject'];
      updated_at?: string;
      user?: components['schemas']['UserObject'];
    } | null;
    MessageFlaggedEvent: {
      cid?: string;
      created_at?: string;
      message?: components['schemas']['Message'];
      type: string;
      user?: components['schemas']['UserObject'];
    };
    MessageModerationResult: {
      action?: string;
      ai_moderation_response?: components['schemas']['ModerationResponse'];
      blocked_word?: string;
      blocklist_name?: string;
      created_at?: string;
      message_id?: string;
      moderated_by?: string;
      moderation_thresholds?: components['schemas']['Thresholds'];
      updated_at?: string;
      user_bad_karma?: boolean;
      user_karma?: number;
    };
    MessageNewEvent: {
      channel_id?: string;
      channel_type?: string;
      cid?: string;
      created_at?: string;
      message?: components['schemas']['Message'];
      team?: string;
      type: string;
      user?: components['schemas']['UserObject'];
      watcher_count?: number;
    } | null;
    MessagePaginationParamsRequest: {
      created_at_after?: string;
      created_at_after_or_equal?: string;
      created_at_before?: string;
      created_at_before_or_equal?: string;
      id_gt?: string;
      id_gte?: string;
      id_lt?: string;
      id_lte?: string;
      limit?: number;
      offset?: number;
    };
    MessageReadEvent: {
      channel_id?: string;
      channel_type?: string;
      cid?: string;
      created_at?: string;
      team?: string;
      type: string;
      user?: components['schemas']['UserObject'];
    } | null;
    /** Represents any chat message */
    MessageRequest: {
      /** Array of message attachments */
      attachments: components['schemas']['AttachmentRequest'][];
      /** Channel unique identifier in <type>:<id> format */
      cid?: number[];
      /** Contains HTML markup of the message */
      html?: string;
      /** Message ID is unique string identifier of the message */
      id?: string;
      /** List of mentioned users */
      mentioned_users?: string[];
      /** Should be empty if `text` is provided */
      mml?: string;
      /** ID of parent message (thread) */
      parent_id?: string;
      /** Date when pinned message expires */
      pin_expires?: string;
      /** Whether message is pinned or not */
      pinned?: boolean;
      /** Date when message got pinned */
      pinned_at?: number[];
      /** Contains user who pinned the message */
      pinned_by?: number[];
      quoted_message_id?: string;
      /** An object containing scores of reactions of each type. Key: reaction type (string), value: total score of reactions (int) */
      reaction_scores?: number[];
      /** Whether thread reply should be shown in the channel as well */
      show_in_channel?: boolean;
      /** Whether message is silent or not */
      silent?: boolean;
      /** Text of the message. Should be empty if `mml` is provided */
      text?: string;
      /** Sender of the message. Required when using server-side API */
      user?: components['schemas']['UserObjectRequest'];
      user_id?: string;
    } & { [key: string]: unknown };
    /** Represents any chat message */
    MessageRequest_1: {
      /** Array of message attachments */
      attachments?: components['schemas']['AttachmentRequest'][];
      /** Whether `before_message_send webhook` failed or not. Field is only accessible in push webhook */
      before_message_send_failed?: boolean;
      /** Channel unique identifier in <type>:<id> format */
      cid?: string;
      /** Contains provided slash command */
      command?: string;
      /** Date/time of creation */
      created_at?: string;
      /** Date/time of deletion */
      deleted_at?: string;
      /** Contains HTML markup of the message */
      html?: string;
      /** Object with translations. Key `language` contains the original language key. Other keys contain translations */
      i18n?: { [key: string]: string };
      /** Message ID is unique string identifier of the message */
      id?: string;
      /** Contains image moderation information */
      image_labels?: { [key: string]: string[] };
      /** List of 10 latest reactions to this message */
      latest_reactions?: components['schemas']['ReactionRequest'][];
      /** List of mentioned users */
      mentioned_users?: components['schemas']['UserObjectRequest'][];
      /** Should be empty if `text` is provided */
      mml: string;
      /** List of 10 latest reactions of authenticated user to this message */
      own_reactions?: components['schemas']['ReactionRequest'][];
      /** ID of parent message (thread) */
      parent_id?: string;
      /** Date when pinned message expires */
      pin_expires?: string;
      /** Whether message is pinned or not */
      pinned?: boolean;
      /** Date when message got pinned */
      pinned_at?: string;
      /** Contains user who pinned the message */
      pinned_by?: components['schemas']['UserObjectRequest'];
      /** Contains quoted message */
      quoted_message?: components['schemas']['MessageRequest_1'];
      quoted_message_id?: string;
      /** An object containing number of reactions of each type. Key: reaction type (string), value: number of reactions (int) */
      reaction_counts?: { [key: string]: number };
      /** An object containing scores of reactions of each type. Key: reaction type (string), value: total score of reactions (int) */
      reaction_scores?: { [key: string]: number };
      /** Number of replies to this message */
      reply_count?: number;
      /** Whether the message was shadowed or not */
      shadowed?: boolean;
      /** Whether thread reply should be shown in the channel as well */
      show_in_channel?: boolean;
      /** Whether message is silent or not */
      silent?: boolean;
      /** Text of the message. Should be empty if `mml` is provided */
      text: string;
      /** List of users who participate in thread */
      thread_participants?: components['schemas']['UserObjectRequest'][];
      /** Contains type of the message */
      type?: 'regular' | 'ephemeral' | 'error' | 'reply' | 'system' | 'deleted';
      /** Date/time of the last update */
      updated_at?: string;
      /** Sender of the message. Required when using server-side API */
      user?: components['schemas']['UserObjectRequest'];
    } & { [key: string]: unknown };
    MessageResponse: {
      /** Duration of the request in human-readable format */
      duration?: string;
      message?: components['schemas']['Message'];
    } | null;
    MessageUnFlaggedEvent: {
      cid?: string;
      created_at?: string;
      message?: components['schemas']['Message'];
      type: string;
      user?: components['schemas']['UserObject'];
    };
    MessageUpdatedEvent: {
      channel_id?: string;
      channel_type?: string;
      cid?: string;
      created_at?: string;
      message?: components['schemas']['Message'];
      team?: string;
      type: string;
      user?: components['schemas']['UserObject'];
    } | null;
    ModerationResponse: {
      explicit?: number;
      spam?: number;
      toxic?: number;
    };
    ModerationResponseRequest: {
      explicit?: number;
      spam?: number;
      toxic?: number;
    };
    MuteChannelRequest:
      | ({
          /** Channel CIDs to mute (if multiple channels) */
          channel_cids: string[];
          /** Duration of mute in milliseconds */
          expiration?: number;
          /** **Server-side only**. User object which server acts upon */
          user?: components['schemas']['UserObjectRequest'];
          /** **Server-side only**. User ID which server acts upon */
          user_id?: string;
        } & {
          channel_cid: unknown;
        })
      | null;
    MuteChannelResponse: {
      /** Object with channel mute (if one channel was muted) */
      channel_mute?: components['schemas']['ChannelMute'];
      /** Object with mutes (if multiple channels were muted) */
      channel_mutes?: components['schemas']['ChannelMute'][];
      /** Duration of the request in human-readable format */
      duration?: string;
      /** Authorized user object with fresh mutes information */
      own_user?: components['schemas']['OwnUser'];
    } | null;
    MuteUserRequest:
      | ({
          /** User IDs to mute (if multiple users) */
          target_ids: string[];
          /** Duration of mute in minutes */
          timeout?: number;
          /** **Server-side only**. User object which server acts upon */
          user?: components['schemas']['UserObjectRequest'];
          /** **Server-side only**. User ID which server acts upon */
          user_id?: string;
        } & {
          target_id: unknown;
        })
      | null;
    MuteUserResponse: {
      /** Duration of the request in human-readable format */
      duration?: string;
      /** Object with user mute (if one user was muted) */
      mute?: components['schemas']['UserMute'];
      /** Object with mutes (if multiple users were muted) */
      mutes?: components['schemas']['UserMute'][];
      /** Authorized user object with fresh mutes information */
      own_user?: components['schemas']['OwnUser'];
    } | null;
    NotificationAddedToChannelEvent: {
      channel?: components['schemas']['ChannelResponse'];
      channel_id?: string;
      channel_type?: string;
      cid?: string;
      created_at?: string;
      team?: string;
      type: string;
    };
    NotificationChannelDeletedEvent: {
      channel?: components['schemas']['ChannelResponse'];
      channel_id?: string;
      channel_type?: string;
      cid?: string;
      created_at?: string;
      team?: string;
      type: string;
    };
    NotificationChannelMutesUpdatedEvent: {
      created_at?: string;
      me?: components['schemas']['OwnUser'];
      type: string;
    };
    NotificationChannelTruncatedEvent: {
      channel?: components['schemas']['ChannelResponse'];
      channel_id?: string;
      channel_type?: string;
      cid?: string;
      created_at?: string;
      type: string;
    };
    NotificationInviteAcceptedEvent: {
      channel?: components['schemas']['ChannelResponse'];
      channel_id?: string;
      channel_type?: string;
      cid?: string;
      created_at?: string;
      member?: components['schemas']['ChannelMember'];
      type: string;
      user?: components['schemas']['UserObject'];
    };
    NotificationInviteRejectedEvent: {
      channel?: components['schemas']['ChannelResponse'];
      channel_id?: string;
      channel_type?: string;
      cid?: string;
      created_at?: string;
      member?: components['schemas']['ChannelMember'];
      type: string;
      user?: components['schemas']['UserObject'];
    };
    NotificationInvitedEvent: {
      channel?: components['schemas']['ChannelResponse'];
      channel_id?: string;
      channel_type?: string;
      cid?: string;
      created_at?: string;
      member?: components['schemas']['ChannelMember'];
      type: string;
      user?: components['schemas']['UserObject'];
    };
    NotificationMarkReadEvent: {
      channel?: components['schemas']['ChannelResponse'];
      channel_id?: string;
      channel_type?: string;
      cid?: string;
      created_at?: string;
      team?: string;
      total_unread_count?: number;
      type: string;
      unread_channels?: number;
      unread_count?: number;
      user?: components['schemas']['UserObject'];
    } | null;
    NotificationMutesUpdatedEvent: {
      created_at?: string;
      me?: components['schemas']['OwnUser'];
      type: string;
    };
    NotificationNewMessageEvent: {
      channel?: components['schemas']['ChannelResponse'];
      channel_id?: string;
      channel_type?: string;
      cid?: string;
      created_at?: string;
      message?: components['schemas']['Message'];
      team?: string;
      type: string;
    };
    NotificationRemovedFromChannelEvent: {
      channel?: components['schemas']['ChannelResponse'];
      channel_id?: string;
      channel_type?: string;
      cid?: string;
      created_at?: string;
      member?: components['schemas']['ChannelMember'];
      type: string;
      user?: components['schemas']['UserObject'];
    };
    OwnUser: {
      banned?: boolean;
      channel_mutes?: components['schemas']['ChannelMute'][];
      created_at?: string;
      deactivated_at?: string;
      deleted_at?: string;
      devices?: components['schemas']['Device'][];
      id?: string;
      invisible?: boolean;
      language?: string;
      last_active?: string;
      latest_hidden_channels?: string[];
      mutes?: components['schemas']['UserMute'][];
      online?: boolean;
      role?: string;
      teams?: string[];
      total_unread_count?: number;
      unread_channels?: number;
      unread_count?: number;
      updated_at?: string;
    } & { [key: string]: unknown };
    OwnUserRequest: {
      banned?: boolean;
      channel_mutes?: components['schemas']['ChannelMuteRequest'][];
      created_at?: string;
      deactivated_at?: string;
      deleted_at?: string;
      devices?: components['schemas']['DeviceRequest'][];
      id?: string;
      invisible?: boolean;
      language?: string;
      last_active?: string;
      latest_hidden_channels?: string[];
      mutes?: components['schemas']['UserMuteRequest'][];
      online?: boolean;
      role?: string;
      teams?: string[];
      total_unread_count?: number;
      unread_channels?: number;
      unread_count?: number;
      updated_at?: string;
    } & { [key: string]: unknown };
    PaginationParamsRequest: {
      id_gt?: number;
      id_gte?: number;
      id_lt?: number;
      id_lte?: number;
      limit?: number;
      offset?: number;
    };
    Permission: {
      /** Action name this permission is for (e.g. SendMessage) */
      action?: string;
      /** MongoDB style condition which decides whether or not the permission is granted */
      condition?: { [key: string]: unknown };
      /** Whether this is a custom permission or built-in */
      custom?: boolean;
      /** Description of the permission */
      description?: string;
      /** Unique permission ID */
      id?: string;
      /** Name of the permission */
      name?: string;
      /** Whether this permission applies to resource owner or not */
      owner?: boolean;
      /** Whether this permission applies to teammates (multi-tenancy mode only) */
      same_team?: boolean;
    };
    Policy: {
      action?: number;
      created_at?: string;
      name?: string;
      owner?: boolean;
      priority?: number;
      resources?: string[];
      roles?: string[];
      updated_at?: string;
    };
    PolicyRequest: {
      action?: 'Deny' | 'Allow';
      /** User-friendly policy name */
      name: string;
      /** Whether policy applies to resource owner or not */
      owner?: boolean;
      /** Policy priority */
      priority: number;
      /** List of resources to apply policy to */
      resources?: string[];
      /** List of roles to apply policy to */
      roles?: string[];
    };
    PolicyRequest_1: {
      action?: 'Deny' | 'Allow';
      /** User-friendly policy name */
      name: string;
      /** Whether policy applies to resource owner or not */
      owner?: boolean;
      /** Policy priority */
      priority: number;
      /** List of resources to apply policy to */
      resources?: string[];
      /** List of roles to apply policy to */
      roles?: string[];
    };
    PushConfigRequest: {
      version?: 'v1' | 'v2';
    };
    PushNotificationFields: {
      apn?: components['schemas']['APNConfigFields'];
      firebase?: components['schemas']['FirebaseConfigFields'];
      huawei?: components['schemas']['HuaweiConfigFields'];
      version?: string;
    };
    QueryBannedUsersRequest: {
      created_at_after?: string;
      created_at_after_or_equal?: string;
      created_at_before?: string;
      created_at_before_or_equal?: string;
      filter_conditions: { [key: string]: unknown };
      limit?: number;
      offset?: number;
      sort?: components['schemas']['SortParam'][];
      /** **Server-side only**. User object which server acts upon */
      user?: components['schemas']['UserObject'];
      /** **Server-side only**. User ID which server acts upon */
      user_id?: string;
    };
    QueryBannedUsersResponse: {
      bans?: components['schemas']['BanResponse'][];
      /** Duration of the request in human-readable format */
      duration?: string;
    } | null;
    QueryChannelsRequest: {
      /** Websocket connection ID to interact with. You can pass it as body or URL parameter */
      connection_id?: string;
      filter_conditions?: { [key: string]: unknown };
      /** Number of channels to limit */
      limit?: number;
      /** Number of members to limit */
      member_limit?: number;
      /** Number of messages to limit */
      message_limit?: number;
      /** Channel pagination offset */
      offset?: number;
      presence?: boolean;
      /** List of sort parameters */
      sort: components['schemas']['SortParamRequest'][];
      /** Whether to update channel state or not */
      state?: boolean;
      /** **Server-side only**. User object which server acts upon */
      user?: components['schemas']['UserObjectRequest'];
      /** **Server-side only**. User ID which server acts upon */
      user_id?: string;
      /** Whether to start watching found channels or not */
      watch?: boolean;
    } | null;
    QueryMembersRequest: {
      created_at_after?: string;
      created_at_after_or_equal?: string;
      created_at_before?: string;
      created_at_before_or_equal?: string;
      /** Filter to apply to members */
      filter_conditions: { [key: string]: unknown };
      /** Channel ID to interact with */
      id?: string;
      limit?: number;
      /** List of members to search in distinct channels */
      members?: components['schemas']['ChannelMember'][];
      offset?: number;
      /** Array of sort parameters */
      sort?: components['schemas']['SortParam'][];
      /** Channel type to interact with */
      type: string;
      /** **Server-side only**. User object which server acts upon */
      user?: components['schemas']['UserObject'];
      /** **Server-side only**. User ID which server acts upon */
      user_id?: string;
      user_id_gt?: string;
      user_id_gte?: string;
      user_id_lt?: string;
      user_id_lte?: string;
    };
    QueryMessageFlagsRequest: {
      filter_conditions?: { [key: string]: unknown };
      limit?: number;
      offset?: number;
      /** **Server-side only**. User object which server acts upon */
      user?: components['schemas']['UserObject'];
      /** **Server-side only**. User ID which server acts upon */
      user_id?: string;
    };
    QueryMessageFlagsResponse: {
      /** Duration of the request in human-readable format */
      duration?: string;
      flags?: components['schemas']['MessageFlag'][];
    } | null;
    QueryUsersRequest: {
      /** Websocket connection ID to interact with. You can pass it as body or URL parameter */
      connection_id?: string;
      /** User filters */
      filter_conditions: { [key: string]: unknown };
      /** Matches IDs that are greater than the specified ID */
      id_gt?: string;
      /** Matches IDs that are greater than or equal to the specified ID */
      id_gte?: string;
      /** Matches IDs that are less than the specified ID */
      id_lt?: string;
      /** Matches IDs that are less than or equal to the specified ID */
      id_lte?: string;
      /** Number of records to return */
      limit?: number;
      /** Number of records to offset */
      offset?: number;
      /** Request user presence status */
      presence?: boolean;
      /** Array of sort parameters */
      sort: components['schemas']['SortParam'][];
      /** **Server-side only**. User object which server acts upon */
      user?: components['schemas']['UserObject'];
      /** **Server-side only**. User ID which server acts upon */
      user_id?: string;
    };
    /** Represents user reaction to a message */
    Reaction:
      | ({
          /** Date/time of creation */
          created_at?: string;
          /** ID of a message user reacted to */
          message_id?: string;
          /** Reaction score. If not specified reaction has score of 1 */
          score?: number;
          /** The type of reaction (e.g. 'like', 'laugh', 'wow') */
          type: string;
          /** Date/time of the last update */
          updated_at?: string;
          user?: components['schemas']['UserObject'];
          /** ID of a user who reacted to a message */
          user_id?: string;
        } & { [key: string]: unknown })
      | null;
    ReactionDeletedEvent: {
      channel_id?: string;
      channel_type?: string;
      cid?: string;
      created_at?: string;
      message?: components['schemas']['Message'];
      reaction?: components['schemas']['Reaction'];
      team?: string;
      type: string;
      user?: components['schemas']['UserObject'];
    } | null;
    ReactionNewEvent: {
      channel_id?: string;
      channel_type?: string;
      cid?: string;
      created_at?: string;
      message?: components['schemas']['Message'];
      reaction?: components['schemas']['Reaction'];
      team?: string;
      type: string;
      user?: components['schemas']['UserObject'];
    } | null;
    ReactionRemovalResponse: {
      /** Duration of the request in human-readable format */
      duration?: string;
      message?: components['schemas']['Message'];
      reaction?: components['schemas']['Reaction'];
    } | null;
    /** Represents user reaction to a message */
    ReactionRequest:
      | ({
          /** ID of a message user reacted to */
          message_id?: string;
          /** Reaction score. If not specified reaction has score of 1 */
          score?: number;
          /** The type of reaction (e.g. 'like', 'laugh', 'wow') */
          type: string;
          user?: components['schemas']['UserObjectRequest'];
          /** ID of a user who reacted to a message */
          user_id?: string;
        } & { [key: string]: unknown })
      | null;
    ReactionResponse: {
      /** Duration of the request in human-readable format */
      duration?: string;
      message?: components['schemas']['Message'];
      reaction?: components['schemas']['Reaction'];
    } | null;
    ReactionUpdatedEvent: {
      channel_id?: string;
      channel_type?: string;
      cid?: string;
      created_at?: string;
      message?: components['schemas']['Message'];
      reaction?: components['schemas']['Reaction'];
      team?: string;
      type: string;
      user?: components['schemas']['UserObject'];
    };
    ReactivateUserRequest: {
      /** **Server-side only**. User ID who's reactivating the user */
      created_by_id?: string;
      /** Set this field to put new name for the user */
      name?: string;
      /** Restore previously deleted messages */
      restore_messages?: boolean;
      user_id: string;
    } | null;
    ReactivateUserResponse: {
      /** Duration of the request in human-readable format */
      duration?: string;
      user?: components['schemas']['UserObject'];
    } | null;
    Read: {
      last_read?: string;
      unread_messages?: number;
      user?: components['schemas']['UserObject'];
    } | null;
    Response: {
      /** Duration of the request in human-readable format */
      duration?: string;
    } | null;
    ResumeCampaignRequest: { [key: string]: unknown };
    ResumeCampaignResponse: {
      campaign?: components['schemas']['Campaign'];
      /** Duration of the request in human-readable format */
      duration?: string;
    } | null;
    Role: {
      /** Date/time of creation */
      created_at?: string;
      /** Whether this is a custom role or built-in */
      custom?: boolean;
      /** Unique role name */
      name?: string;
      /** Date/time of the last update */
      updated_at?: string;
    };
    ScheduleCampaignRequest: {
      send_at?: number;
    } | null;
    ScheduleCampaignResponse: {
      campaign?: components['schemas']['Campaign'];
      /** Duration of the request in human-readable format */
      duration?: string;
    } | null;
    SearchRequest: {
      /** Channel filter conditions */
      filter_conditions: { [key: string]: unknown };
      /** Number of messages to return */
      limit?: number;
      /** Message filter conditions */
      message_filter_conditions?: { [key: string]: unknown };
      /** Pagination parameter. Cannot be used with non-zero offset. */
      next?: string;
      /** Pagination offset. Cannot be used with sort or next. */
      offset?: number;
      /** Search phrase */
      query?: string;
      /** Sort parameters. Cannot be used with non-zero offset */
      sort?: components['schemas']['SortParam'][];
    };
    SearchResponse: {
      /** Duration of the request in human-readable format */
      duration?: string;
      /** Value to pass to the next search query in order to paginate */
      next?: string;
      /** Value that points to the previous page. Pass as the next value in a search query to paginate backwards */
      previous?: string;
      /** Search results */
      results?: components['schemas']['SearchResult'][];
      /** Warning about the search results */
      results_warning?: components['schemas']['SearchWarning'];
    } | null;
    SearchResult: {
      /** Found message */
      message?: components['schemas']['SearchResultMessage'];
    } | null;
    SearchResultMessage: {
      /** Array of message attachments */
      attachments?: components['schemas']['Attachment'][];
      /** Whether `before_message_send webhook` failed or not. Field is only accessible in push webhook */
      before_message_send_failed?: boolean;
      /** Channel object */
      channel?: components['schemas']['ChannelResponse'];
      /** Channel unique identifier in <type>:<id> format */
      cid?: string;
      /** Contains provided slash command */
      command?: string;
      /** Date/time of creation */
      created_at?: string;
      /** Date/time of deletion */
      deleted_at?: string;
      /** Contains HTML markup of the message */
      html?: string;
      /** Object with translations. Key `language` contains the original language key. Other keys contain translations */
      i18n?: { [key: string]: string };
      /** Message ID is unique string identifier of the message */
      id?: string;
      /** Contains image moderation information */
      image_labels?: { [key: string]: string[] };
      /** List of 10 latest reactions to this message */
      latest_reactions?: components['schemas']['Reaction'][];
      /** List of mentioned users */
      mentioned_users?: components['schemas']['UserObject'][];
      /** Should be empty if `text` is provided */
      mml: string;
      /** List of 10 latest reactions of authenticated user to this message */
      own_reactions?: components['schemas']['Reaction'][];
      /** ID of parent message (thread) */
      parent_id?: string;
      /** Date when pinned message expires */
      pin_expires?: string;
      /** Whether message is pinned or not */
      pinned?: boolean;
      /** Date when message got pinned */
      pinned_at?: string;
      /** Contains user who pinned the message */
      pinned_by?: components['schemas']['UserObject'];
      /** Contains quoted message */
      quoted_message?: components['schemas']['Message'];
      quoted_message_id?: string;
      /** An object containing number of reactions of each type. Key: reaction type (string), value: number of reactions (int) */
      reaction_counts?: { [key: string]: number };
      /** An object containing scores of reactions of each type. Key: reaction type (string), value: total score of reactions (int) */
      reaction_scores?: { [key: string]: number };
      /** Number of replies to this message */
      reply_count?: number;
      /** Whether the message was shadowed or not */
      shadowed?: boolean;
      /** Whether thread reply should be shown in the channel as well */
      show_in_channel?: boolean;
      /** Whether message is silent or not */
      silent?: boolean;
      /** Text of the message. Should be empty if `mml` is provided */
      text: string;
      /** List of users who participate in thread */
      thread_participants?: components['schemas']['UserObject'][];
      /** Contains type of the message */
      type?: 'regular' | 'ephemeral' | 'error' | 'reply' | 'system' | 'deleted';
      /** Date/time of the last update */
      updated_at?: string;
      /** Sender of the message. Required when using server-side API */
      user?: components['schemas']['UserObject'];
    } & { [key: string]: unknown };
    SearchWarning: {
      /** Channel CIDs for the searched channels */
      channel_search_cids?: string[];
      /** Number of channels searched */
      channel_search_count?: number;
      /** Code corresponding to the warning */
      warning_code?: number;
      /** Description of the warning */
      warning_description?: string;
    };
    Segment: {
      channel_count?: number;
      created_at?: string;
      deleted_at?: string;
      description: string;
      filter: components['schemas']['SegmentFilter'];
      id?: string;
      name: string;
      status?: string;
      updated_at?: string;
      user_count?: number;
    };
    SegmentDataRequest: {
      description: string;
      filter: components['schemas']['SegmentFilterRequest'];
      name: string;
    };
    SegmentFilter: {
      channel?: { [key: string]: unknown };
      user?: { [key: string]: unknown };
    };
    SegmentFilterRequest: {
      channel?: { [key: string]: unknown };
      user?: { [key: string]: unknown };
    };
    SegmentUpdateableFieldsRequest: {
      description?: string;
      filter?: components['schemas']['SegmentFilterRequest'];
      name?: string;
    };
    SendEventRequest: {
      event: components['schemas']['EventRequest'];
    } | null;
    /** Contains all information needed to send new message */
    SendMessageRequest: {
      message: components['schemas']['MessageRequest'];
      /** Disables all push notifications for this message */
      skip_push?: boolean;
    } | null;
    SendReactionRequest: {
      /** Whether to replace all existing user reactions */
      enforce_unique?: boolean;
      reaction: components['schemas']['ReactionRequest'];
      /** Skips any mobile push notifications */
      skip_push?: boolean;
    } | null;
    SendUserCustomEventRequest: {
      event: components['schemas']['UserCustomEventRequest'];
    } | null;
    ShowChannelRequest: {
      /** **Server-side only**. User object which server acts upon */
      user?: components['schemas']['UserObjectRequest'];
      /** **Server-side only**. User ID which server acts upon */
      user_id?: string;
    } | null;
    ShowChannelResponse: {
      /** Duration of the request in human-readable format */
      duration?: string;
    } | null;
    SortParam: {
      direction?: number;
      field?: string;
    } | null;
    SortParamRequest: {
      direction?: number;
      field?: string;
    } | null;
    StopCampaignRequest: { [key: string]: unknown } | null;
    StopCampaignResponse: {
      campaign?: components['schemas']['Campaign'];
      /** Duration of the request in human-readable format */
      duration?: string;
    } | null;
    StopWatchingResponse: {
      /** Duration of the request in human-readable format */
      duration?: string;
    } | null;
    SyncRequest: {
      /** List of channel CIDs to sync */
      channel_cids?: string[];
      /** Date from which synchronization should happen */
      last_sync_at: string;
      /** **Server-side only**. User object which server acts upon */
      user?: components['schemas']['UserObjectRequest'];
      /** **Server-side only**. User ID which server acts upon */
      user_id?: string;
      /** If set to true this will add 'inaccessible_cids' to response type */
      with_inaccessible_cids?: boolean;
    } | null;
    SyncResponse: {
      /** Duration of the request in human-readable format */
      duration?: string;
      /** List of events */
      events?: components['schemas']['Event'][];
      /** List of CIDs that user can't access */
      inaccessible_cids?: string[];
    } | null;
    TestCampaignRequest: {
      users: string[];
    } | null;
    TestCampaignResponse: {
      campaign?: components['schemas']['Campaign'];
      /** Duration of the request in human-readable format */
      duration?: string;
    } | null;
    /** Sets thresholds for AI moderation */
    Thresholds: {
      /** Thresholds for explicit messages */
      explicit?: components['schemas']['LabelThresholds'];
      /** Thresholds for spam */
      spam?: components['schemas']['LabelThresholds'];
      /** Thresholds for toxic messages */
      toxic?: components['schemas']['LabelThresholds'];
    };
    /** Sets thresholds for AI moderation */
    ThresholdsRequest: {
      /** Thresholds for explicit messages */
      explicit?: components['schemas']['LabelThresholdsRequest'];
      /** Thresholds for spam */
      spam?: components['schemas']['LabelThresholdsRequest'];
      /** Thresholds for toxic messages */
      toxic?: components['schemas']['LabelThresholdsRequest'];
    };
    TranslateMessageRequest: {
      /** Language to translate message to */
      language:
        | 'af'
        | 'sq'
        | 'am'
        | 'ar'
        | 'az'
        | 'bn'
        | 'bs'
        | 'bg'
        | 'zh'
        | 'zh-TW'
        | 'hr'
        | 'cs'
        | 'da'
        | 'fa-AF'
        | 'nl'
        | 'en'
        | 'et'
        | 'fi'
        | 'fr'
        | 'fr-CA'
        | 'ka'
        | 'de'
        | 'el'
        | 'ha'
        | 'he'
        | 'hi'
        | 'hu'
        | 'id'
        | 'it'
        | 'ja'
        | 'ko'
        | 'lv'
        | 'ms'
        | 'no'
        | 'fa'
        | 'ps'
        | 'pl'
        | 'pt'
        | 'ro'
        | 'ru'
        | 'sr'
        | 'sk'
        | 'sl'
        | 'so'
        | 'es'
        | 'es-MX'
        | 'sw'
        | 'sv'
        | 'tl'
        | 'ta'
        | 'th'
        | 'tr'
        | 'uk'
        | 'ur'
        | 'vi';
    } | null;
    TruncateChannelRequest: { [key: string]: unknown } | null;
    TruncateChannelResponse: {
      channel?: components['schemas']['ChannelResponse'];
      /** Duration of the request in human-readable format */
      duration?: string;
    } | null;
    TypingStartEvent: {
      channel_id?: string;
      channel_type?: string;
      cid?: string;
      created_at?: string;
      parent_id?: string;
      type: string;
      user?: components['schemas']['UserObject'];
    };
    TypingStopEvent: {
      channel_id?: string;
      channel_type?: string;
      cid?: string;
      created_at?: string;
      parent_id?: string;
      type: string;
      user?: components['schemas']['UserObject'];
    };
    UnmuteChannelRequest:
      | ({
          /** Channel CIDs to mute (if multiple channels) */
          channel_cids: string[];
          /** Duration of mute in milliseconds */
          expiration?: number;
          /** **Server-side only**. User object which server acts upon */
          user?: components['schemas']['UserObjectRequest'];
          /** **Server-side only**. User ID which server acts upon */
          user_id?: string;
        } & {
          channel_cid: unknown;
        })
      | null;
    UnmuteResponse: {
      /** Duration of the request in human-readable format */
      duration?: string;
    } | null;
    UnmuteUserRequest:
      | ({
          /** User IDs to mute (if multiple users) */
          target_ids: string[];
          /** Duration of mute in minutes */
          timeout?: number;
          /** **Server-side only**. User object which server acts upon */
          user?: components['schemas']['UserObjectRequest'];
          /** **Server-side only**. User ID which server acts upon */
          user_id?: string;
        } & {
          target_id: unknown;
        })
      | null;
    UpdateAppRequest: {
      apn_config?: components['schemas']['APNConfigRequest'];
      async_url_enrich_enabled?: boolean;
      auto_translation_enabled?: boolean;
      before_message_send_hook_url?: string;
      channel_hide_members_only?: boolean;
      custom_action_handler_url?: string;
      disable_auth_checks?: boolean;
      disable_permissions_checks?: boolean;
      enforce_unique_usernames?: 'no' | 'app' | 'team';
      file_upload_config?: components['schemas']['FileUploadConfigRequest'];
      firebase_config?: components['schemas']['FirebaseConfigRequest'];
      grants?: { [key: string]: string[] };
      huawei_config?: components['schemas']['HuaweiConfigRequest'];
      image_moderation_enabled?: boolean;
      image_moderation_labels?: string[];
      image_upload_config?: components['schemas']['FileUploadConfigRequest'];
      migrate_permissions_to_v2?: boolean;
      multi_tenant_enabled?: boolean;
      permission_version?: 'v1' | 'v2';
      push_config?: components['schemas']['PushConfigRequest'];
      revoke_tokens_issued_before?: string;
      sqs_key?: string;
      sqs_secret?: string;
      sqs_url?: string;
      user_search_disallowed_roles?: string[];
      webhook_url?: string;
    } | null;
    UpdateBlockListRequest: {
      words?: string[];
    } | null;
    UpdateCampaignRequest: {
      campaign?: components['schemas']['CampaignUpdateableFieldsRequest'];
    } | null;
    UpdateCampaignResponse: {
      campaign?: components['schemas']['Campaign'];
      /** Duration of the request in human-readable format */
      duration?: string;
    } | null;
    UpdateChannelPartialRequest: {
      /** Sets new field values */
      set: { [key: string]: unknown };
      /** Array of field names to unset */
      unset: string[];
      /** **Server-side only**. User object which server acts upon */
      user?: components['schemas']['UserObjectRequest'];
      /** **Server-side only**. User ID which server acts upon */
      user_id?: string;
    } | null;
    UpdateChannelPartialResponse: {
      channel?: components['schemas']['ChannelResponse'];
      /** Duration of the request in human-readable format */
      duration?: string;
      members?: components['schemas']['ChannelMember'][];
    } | null;
    UpdateChannelRequest: {
      /** Set to `true` to accept the invite */
      accept_invite?: boolean;
      /** List of user IDs to add to the channel */
      add_members?: components['schemas']['ChannelMemberRequest'][];
      /** List of user IDs to make channel moderators */
      add_moderators: string[];
      /** List of channel member role assignments. If any specified user is not part of the channel, the request will fail */
      assign_roles?: components['schemas']['ChannelMemberRequest'][];
      /** Sets cool down period for the channel in seconds */
      cooldown?: number;
      /** Channel data to update */
      data?: components['schemas']['ChannelRequest'];
      /** List of user IDs to take away moderators status from */
      demote_moderators: string[];
      /** List of user IDs to invite to the channel */
      invites?: components['schemas']['ChannelMemberRequest'][];
      /** Message to send to the chat when channel is successfully updated */
      message?: components['schemas']['MessageRequest'];
      /** Set to `true` to reject the invite */
      reject_invite?: boolean;
      /** List of user IDs to remove from the channel */
      remove_members: string[];
      /** When `message` is set disables all push notifications for it */
      skip_push?: boolean;
      /** **Server-side only**. User object which server acts upon */
      user?: components['schemas']['UserObjectRequest'];
      /** **Server-side only**. User ID which server acts upon */
      user_id?: string;
    } | null;
    UpdateChannelResponse: {
      channel?: components['schemas']['ChannelResponse'];
      /** Duration of the request in human-readable format */
      duration?: string;
      members?: components['schemas']['ChannelMember'][];
      message?: components['schemas']['Message'];
    } | null;
    UpdateChannelTypeRequest: {
      /** Enables automatic message moderation */
      automod: 'disabled' | 'simple' | 'AI';
      /** Sets behavior of automatic moderation */
      automod_behavior?: 'flag' | 'block';
      automod_thresholds?: components['schemas']['ThresholdsRequest'];
      /** Name of the blocklist to use */
      blocklist?: string;
      /** Sets behavior of blocklist */
      blocklist_behavior?: 'flag' | 'block';
      /** List of commands that channel supports */
      commands?: string[];
      /** Connect events support */
      connect_events?: boolean;
      /** Enables custom events */
      custom_events?: boolean;
      grants?: { [key: string]: string[] };
      /** Number of maximum message characters */
      max_message_length?: number;
      /** Number of days to keep messages. 'infinite' disables retention */
      message_retention?: string;
      /** Enables mutes */
      mutes?: boolean;
      permissions?: components['schemas']['PolicyRequest'][];
      /** Enables push notifications */
      push_notifications?: boolean;
      /** Enables message reactions */
      reactions?: boolean;
      /** Read events support */
      read_events?: boolean;
      /** Enables message replies (threads) */
      replies?: boolean;
      /** Enables message search */
      search?: boolean;
      /** Typing events support */
      typing_events?: boolean;
      /** Enables file uploads */
      uploads?: boolean;
      /** Enables URL enrichment */
      url_enrichment?: boolean;
    } | null;
    UpdateChannelTypeResponse: {
      /** Enables automatic message moderation */
      automod: 'disabled' | 'simple' | 'AI';
      /** Sets behavior of automatic moderation */
      automod_behavior?: 'flag' | 'block';
      automod_thresholds?: components['schemas']['Thresholds'];
      /** Name of the blocklist to use */
      blocklist?: string;
      /** Sets behavior of blocklist */
      blocklist_behavior?: 'flag' | 'block';
      /** List of commands that channel supports */
      commands?: string[];
      /** Connect events support */
      connect_events?: boolean;
      /** Date/time of creation */
      created_at?: string;
      /** Enables custom events */
      custom_events?: boolean;
      /** Duration of the request in human-readable format */
      duration?: string;
      grants?: { [key: string]: string[] };
      /** Number of maximum message characters */
      max_message_length?: number;
      /** Number of days to keep messages. 'infinite' disables retention */
      message_retention?: string;
      /** Enables mutes */
      mutes?: boolean;
      /** Channel type name */
      name?: string;
      permissions?: components['schemas']['PolicyRequest_1'][];
      /** Enables push notifications */
      push_notifications?: boolean;
      /** Enables message reactions */
      reactions?: boolean;
      /** Read events support */
      read_events?: boolean;
      /** Enables message replies (threads) */
      replies?: boolean;
      /** Enables message search */
      search?: boolean;
      /** Typing events support */
      typing_events?: boolean;
      /** Date/time of the last update */
      updated_at?: string;
      /** Enables file uploads */
      uploads?: boolean;
      /** Enables URL enrichment */
      url_enrichment?: boolean;
    } | null;
    /** Represents custom chat command */
    UpdateCommandRequest: {
      /** Arguments help text, shown in commands auto-completion */
      args?: string;
      /** Description, shown in commands auto-completion */
      description: string;
      /** Set name used for grouping commands */
      set?: string;
    } | null;
    UpdateCommandResponse: {
      command?: components['schemas']['Command'];
      /** Duration of the request in human-readable format */
      duration?: string;
    } | null;
    UpdateMessagePartialRequest: {
      /** Sets new field values */
      set: { [key: string]: unknown };
      /** Array of field names to unset */
      unset: string[];
      /** **Server-side only**. User object which server acts upon */
      user?: components['schemas']['UserObjectRequest'];
      /** **Server-side only**. User ID which server acts upon */
      user_id?: string;
    } | null;
    UpdateMessageRequest: {
      message: components['schemas']['MessageRequest'];
    } | null;
    UpdateSegmentRequest: {
      segment?: components['schemas']['SegmentUpdateableFieldsRequest'];
    } | null;
    UpdateSegmentResponse: {
      /** Duration of the request in human-readable format */
      duration?: string;
      segment?: components['schemas']['Segment'];
    } | null;
    UpdateUserPartialRequest: {
      /** User ID to update */
      id: string;
      /** Sets new field values */
      set: { [key: string]: unknown };
      /** Array of field names to unset */
      unset: string[];
    } | null;
    UpdateUsersRequest: {
      /** Object containing users */
      users: { [key: string]: components['schemas']['UserObjectRequest'] };
    } | null;
    UpdateUsersResponse: {
      /** Duration of the request in human-readable format */
      duration?: string;
      /** Object containing users */
      users?: { [key: string]: components['schemas']['UserObject'] };
    } | null;
    UserBannedEvent: {
      channel_id?: string;
      channel_type?: string;
      cid?: string;
      created_at?: string;
      created_by?: components['schemas']['UserObject'];
      expiration?: string;
      reason?: string;
      shadow?: boolean;
      team?: string;
      type: string;
      user?: components['schemas']['UserObject'];
    } | null;
    UserCustomEventRequest: {
      created_at?: string;
      type: string;
    } & { [key: string]: unknown };
    UserDeactivatedEvent: {
      created_at?: string;
      created_by?: components['schemas']['UserObject'];
      type: string;
      user?: components['schemas']['UserObject'];
    } | null;
    UserDeletedEvent: {
      created_at?: string;
      delete_conversation_channels?: boolean;
      hard_delete?: boolean;
      mark_messages_deleted?: boolean;
      type: string;
      user?: components['schemas']['UserObject'];
    } | null;
    UserFlaggedEvent: {
      created_at?: string;
      target_user?: string;
      target_users?: string[];
      type: string;
      user?: components['schemas']['UserObject'];
    };
    UserMute: {
      /** Date/time of creation */
      created_at?: string;
      /** Date/time of mute expiration */
      expires?: string;
      /** User who's muted */
      target?: components['schemas']['UserObject'];
      /** Date/time of the last update */
      updated_at?: string;
      /** Owner of channel mute */
      user?: components['schemas']['UserObject'];
    } | null;
    UserMuteRequest: {
      /** Date/time of creation */
      created_at?: string;
      /** Date/time of mute expiration */
      expires?: string;
      /** User who's muted */
      target?: components['schemas']['UserObjectRequest'];
      /** Date/time of the last update */
      updated_at?: string;
      /** Owner of channel mute */
      user?: components['schemas']['UserObjectRequest'];
    } | null;
    UserMutedEvent: {
      created_at?: string;
      target_user?: string;
      target_users?: string[];
      type: string;
      user?: components['schemas']['UserObject'];
    } | null;
    /** Represents chat user */
    UserObject: {
      /** Expiration date of the ban */
      ban_expires?: string;
      /** Whether a user is banned or not */
      banned?: boolean;
      /** Date/time of creation */
      created_at?: string;
      /** Date of deactivation */
      deactivated_at?: string;
      /** Date/time of deletion */
      deleted_at?: string;
      /** Unique user identifier */
      id: string;
      invisible?: boolean;
      /** Preferred language of a user */
      language?: string;
      /** Date of last activity */
      last_active?: string;
      /** Whether a user online or not */
      online?: boolean;
      /** Revocation date for tokens */
      revoke_tokens_issued_before?: string;
      /** Determines the set of user permissions */
      role?: string;
      /** List of teams user is a part of */
      teams?: string[];
      /** Date/time of the last update */
      updated_at?: string;
    } & { [key: string]: unknown };
    /** Represents chat user */
    UserObjectRequest: {
      /** Expiration date of the ban */
      ban_expires?: string;
      /** Whether a user is banned or not */
      banned?: boolean;
      /** Unique user identifier */
      id: string;
      invisible?: boolean;
      /** Preferred language of a user */
      language?: string;
      /** Revocation date for tokens */
      revoke_tokens_issued_before?: string;
      /** Determines the set of user permissions */
      role?: string;
      /** List of teams user is a part of */
      teams?: string[];
    } & { [key: string]: unknown };
    UserPresenceChangedEvent: {
      created_at?: string;
      type: string;
      user?: components['schemas']['UserObject'];
    };
    UserReactivatedEvent: {
      created_at?: string;
      type: string;
      user?: components['schemas']['UserObject'];
    } | null;
    UserResponse:
      | ({
          /** Expiration date of the ban */
          ban_expires?: string;
          /** Whether a user is banned or not */
          banned?: boolean;
          /** Date/time of creation */
          created_at?: string;
          /** Date of deactivation */
          deactivated_at?: string;
          /** Date/time of deletion */
          deleted_at?: string;
          /** Unique user identifier */
          id: string;
          invisible?: boolean;
          /** Preferred language of a user */
          language?: string;
          /** Date of last activity */
          last_active?: string;
          /** Whether a user online or not */
          online?: boolean;
          /** Revocation date for tokens */
          revoke_tokens_issued_before?: string;
          /** Determines the set of user permissions */
          role?: string;
          /** Whether user is shadow banned or not */
          shadow_banned?: boolean;
          /** List of teams user is a part of */
          teams?: string[];
          /** Date/time of the last update */
          updated_at?: string;
        } & { [key: string]: unknown })
      | null;
    UserUnbannedEvent: {
      channel_id?: string;
      channel_type?: string;
      cid?: string;
      created_at?: string;
      shadow?: boolean;
      team?: string;
      type: string;
      user?: components['schemas']['UserObject'];
    } | null;
    UserUnflaggedEvent: {
      created_at?: string;
      target_user?: string;
      target_users?: string[];
      type: string;
      user?: components['schemas']['UserObject'];
    };
    UserUnmutedEvent: {
      created_at?: string;
      target_user?: string;
      target_users?: string[];
      type: string;
      user?: components['schemas']['UserObject'];
    } | null;
    UserUpdatedEvent: {
      created_at?: string;
      type: string;
      user?: components['schemas']['UserObject'];
    } | null;
    UserWatchingStartEvent: {
      channel_id?: string;
      channel_type?: string;
      cid?: string;
      created_at?: string;
      team?: string;
      type: string;
      user?: components['schemas']['UserObject'];
      watcher_count?: number;
    } | null;
    UserWatchingStopEvent: {
      channel_id?: string;
      channel_type?: string;
      cid?: string;
      created_at?: string;
      type: string;
      user?: components['schemas']['UserObject'];
      watcher_count?: number;
    } | null;
    UsersResponse: {
      /** Duration of the request in human-readable format */
      duration?: string;
      /** List of found users */
      users?: components['schemas']['UserResponse'][];
    } | null;
  };
}

export interface operations {
  /** This method returns the application settings */
  GetApp: {
    responses: {
      /** Successful response */
      200: {
        content: {
          'application/json': components['schemas']['GetApplicationResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
  };
  /** This method updates one or more application settings */
  UpdateApp: {
    responses: {
      /** Successful response */
      200: {
        content: {
          'application/json': components['schemas']['Response'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateAppRequest'];
      };
    };
  };
  /** Returns all available block lists */
  ListBlockLists: {
    responses: {
      /** Successful response */
      200: {
        content: {
          'application/json': components['schemas']['ListBlockListResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
  };
  /** Creates a new application blocklist, once created the blocklist can be used by any channel type */
  CreateBlockList: {
    responses: {
      /** Successful response */
      201: {
        content: {
          'application/json': components['schemas']['Response'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
    /** Block list */
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateBlockListRequest'];
      };
    };
  };
  /** Returns block list by given name */
  GetBlockList: {
    parameters: {
      path: {
        name: unknown;
      };
    };
    responses: {
      /** Successful response */
      200: {
        content: {
          'application/json': components['schemas']['GetBlockListResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
  };
  /** Updates contents of the block list */
  UpdateBlockList: {
    parameters: {
      path: {
        name: unknown;
      };
    };
    responses: {
      /** Successful response */
      201: {
        content: {
          'application/json': components['schemas']['Response'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateBlockListRequest'];
      };
    };
  };
  /** Deletes previously created application blocklist */
  DeleteBlockList: {
    parameters: {
      path: {
        name: unknown;
      };
    };
    responses: {
      /** Successful response */
      200: {
        content: {
          'application/json': components['schemas']['Response'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
  };
  /** List campaigns */
  ListCampaigns: {
    responses: {
      /** Successful response */
      200: {
        content: {
          'application/json': components['schemas']['ListCampaignsResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
  };
  /** Creates a new campaign */
  CreateCampaign: {
    responses: {
      /** Successful response */
      201: {
        content: {
          'application/json': components['schemas']['CreateCampaignResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateCampaignRequest'];
      };
    };
  };
  /** Get a campaign */
  GetCampaign: {
    parameters: {
      path: {
        id: unknown;
      };
    };
    responses: {
      /** Successful response */
      200: {
        content: {
          'application/json': components['schemas']['GetCampaignResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
  };
  /** Update an existing campaign */
  UpdateCampaign: {
    parameters: {
      path: {
        id: unknown;
      };
    };
    responses: {
      /** Successful response */
      201: {
        content: {
          'application/json': components['schemas']['UpdateCampaignResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateCampaignRequest'];
      };
    };
  };
  /** Delete a campaign */
  DeleteCampaign: {
    parameters: {
      path: {
        id: unknown;
      };
    };
    responses: {
      /** Successful response */
      200: {
        content: {
          'application/json': components['schemas']['DeleteCampaignResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
  };
  /** Resume a stopped campaign */
  ResumeCampaign: {
    parameters: {
      path: {
        id: unknown;
      };
    };
    responses: {
      /** Successful response */
      200: {
        content: {
          'application/json': components['schemas']['ResumeCampaignResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
  };
  /** Schedule a campaign */
  ScheduleCampaign: {
    parameters: {
      path: {
        id: unknown;
      };
    };
    responses: {
      /** Successful response */
      200: {
        content: {
          'application/json': components['schemas']['ScheduleCampaignResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ScheduleCampaignRequest'];
      };
    };
  };
  /** Stop a running campaign */
  StopCampaign: {
    parameters: {
      path: {
        id: unknown;
      };
    };
    responses: {
      /** Successful response */
      200: {
        content: {
          'application/json': components['schemas']['StopCampaignResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
  };
  /** Test a campaign */
  TestCampaign: {
    parameters: {
      path: {
        id: unknown;
      };
    };
    responses: {
      /** Successful response */
      201: {
        content: {
          'application/json': components['schemas']['TestCampaignResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TestCampaignRequest'];
      };
    };
  };
  /** Query channels with filter query */
  QueryChannels: {
    parameters: {
      query: {
        connection_id?: unknown;
      };
    };
    responses: {
      /** Channels list */
      201: {
        content: {
          'application/json': components['schemas']['ChannelsResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
    /** Query Channels Request */
    requestBody: {
      content: {
        'application/json': components['schemas']['QueryChannelsRequest'];
      };
    };
  };
  /** Allows to delete several channels at once asynchronously */
  DeleteChannels: {
    responses: {
      /** Successful response */
      201: {
        content: {
          'application/json': components['schemas']['DeleteChannelsResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeleteChannelsRequest'];
      };
    };
  };
  /** Marks all user channels as read */
  MarkAllRead: {
    responses: {
      /** Successful response */
      201: {
        content: {
          'application/json': components['schemas']['Response'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['MarkReadAllRequest'];
      };
    };
  };
  /** This method creates a channel or returns an existing one with matching attributes */
  GetOrCreateChannel_type: {
    parameters: {
      path: {
        type: unknown;
      };
      query: {
        connection_id?: unknown;
      };
    };
    responses: {
      /** Successful response */
      201: {
        content: {
          'application/json': components['schemas']['ChannelStateResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ChannelGetOrCreateRequest'];
      };
    };
  };
  /** Change channel data */
  UpdateChannel: {
    parameters: {
      path: {
        type: unknown;
        id: unknown;
      };
    };
    responses: {
      /** Successful response */
      201: {
        content: {
          'application/json': components['schemas']['UpdateChannelResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
    /** Channel update request */
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateChannelRequest'];
      };
    };
  };
  /** Deletes channel */
  DeleteChannel: {
    parameters: {
      path: {
        type: unknown;
        id: unknown;
      };
    };
    responses: {
      /** Successful response */
      200: {
        content: {
          'application/json': components['schemas']['DeleteChannelResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
  };
  /** Updates certain fields of the channel */
  UpdateChannelPartial: {
    parameters: {
      path: {
        type: unknown;
        id: unknown;
      };
    };
    responses: {
      /** Successful response */
      200: {
        content: {
          'application/json': components['schemas']['UpdateChannelPartialResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateChannelPartialRequest'];
      };
    };
  };
  /** Sends event to the channel */
  SendEvent: {
    parameters: {
      path: {
        type: unknown;
        id: unknown;
      };
    };
    responses: {
      /** Successful response */
      201: {
        content: {
          'application/json': components['schemas']['EventResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SendEventRequest'];
      };
    };
  };
  /** Uploads file */
  UploadFile: {
    parameters: {
      path: {
        type: unknown;
        id: unknown;
      };
    };
    responses: {
      /** Successful response */
      201: {
        content: {
          'application/json': components['schemas']['FileUploadResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['FileUploadRequest'];
      };
    };
  };
  /** Deletes previously uploaded file */
  DeleteFile: {
    parameters: {
      query: {
        url?: unknown;
      };
    };
    responses: {
      /** Successful response */
      200: {
        content: {
          'application/json': components['schemas']['FileDeleteResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
  };
  /** Marks channel as hidden for current user */
  HideChannel: {
    parameters: {
      path: {
        type: unknown;
        id: unknown;
      };
    };
    responses: {
      /** Successful response */
      201: {
        content: {
          'application/json': components['schemas']['HideChannelResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['HideChannelRequest'];
      };
    };
  };
  /** Uploads image */
  UploadImage: {
    parameters: {
      path: {
        type: unknown;
        id: unknown;
      };
    };
    responses: {
      /** Successful response */
      201: {
        content: {
          'application/json': components['schemas']['ImageUploadResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ImageUploadRequest'];
      };
    };
  };
  /** Deletes previously uploaded image */
  DeleteImage: {
    parameters: {
      query: {
        url?: unknown;
      };
    };
    responses: {
      /** Successful response */
      200: {
        content: {
          'application/json': components['schemas']['FileDeleteResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
  };
  /** Sends new message to the specified channel */
  SendMessage: {
    parameters: {
      path: {
        type: unknown;
        id: unknown;
      };
    };
    responses: {
      /** Successful response */
      201: {
        content: {
          'application/json': components['schemas']['MessageResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
    /** Send Message Request */
    requestBody: {
      content: {
        'application/json': components['schemas']['SendMessageRequest'];
      };
    };
  };
  /** Returns list messages found by IDs */
  GetManyMessages: {
    parameters: {
      path: {
        type: unknown;
        id: unknown;
      };
      query: {
        ids?: unknown;
      };
    };
    responses: {
      /** Successful response */
      200: {
        content: {
          'application/json': components['schemas']['GetManyMessagesResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
  };
  /** This method creates a channel or returns an existing one with matching attributes */
  GetOrCreateChannel_type_id: {
    parameters: {
      path: {
        type: unknown;
        id: unknown;
      };
      query: {
        connection_id?: unknown;
      };
    };
    responses: {
      /** Successful response */
      201: {
        content: {
          'application/json': components['schemas']['ChannelStateResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ChannelGetOrCreateRequest'];
      };
    };
  };
  /** Marks channel as read up to the specific message */
  MarkRead: {
    parameters: {
      path: {
        type: unknown;
        id: unknown;
      };
    };
    responses: {
      /** Successful response */
      201: {
        content: {
          'application/json': components['schemas']['MarkReadResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['MarkReadRequest'];
      };
    };
  };
  /** Shows previously hidden channel */
  ShowChannel: {
    parameters: {
      path: {
        type: unknown;
        id: unknown;
      };
    };
    responses: {
      /** Successful response */
      201: {
        content: {
          'application/json': components['schemas']['ShowChannelResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ShowChannelRequest'];
      };
    };
  };
  /** Call this method to stop receiving channel events */
  StopWatchingChannel: {
    parameters: {
      path: {
        type: unknown;
        id: unknown;
      };
      query: {
        connection_id?: unknown;
      };
    };
    responses: {
      /** Successful response */
      201: {
        content: {
          'application/json': components['schemas']['StopWatchingResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ChannelStopWatchingRequest'];
      };
    };
  };
  /** Truncates channel */
  TruncateChannel: {
    parameters: {
      path: {
        type: unknown;
        id: unknown;
      };
    };
    responses: {
      /** Successful response */
      201: {
        content: {
          'application/json': components['schemas']['TruncateChannelResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
  };
  /** Lists all available channel types */
  ListChannelTypes: {
    responses: {
      /** Successful response */
      200: {
        content: {
          'application/json': components['schemas']['ListChannelTypesResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
  };
  /** Creates new channel type */
  CreateChannelType: {
    responses: {
      /** Successful response */
      201: {
        content: {
          'application/json': components['schemas']['CreateChannelTypeResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateChannelTypeRequest'];
      };
    };
  };
  /** Gets channel type */
  GetChannelType: {
    parameters: {
      path: {
        name: unknown;
      };
    };
    responses: {
      /** Successful response */
      200: {
        content: {
          'application/json': components['schemas']['Response'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
  };
  /** Updates channel type */
  UpdateChannelType: {
    parameters: {
      path: {
        name: unknown;
      };
    };
    responses: {
      /** Successful response */
      201: {
        content: {
          'application/json': components['schemas']['UpdateChannelTypeResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateChannelTypeRequest'];
      };
    };
  };
  /** Deletes channel type */
  DeleteChannelType: {
    parameters: {
      path: {
        name: unknown;
      };
    };
    responses: {
      /** Successful response */
      200: {
        content: {
          'application/json': components['schemas']['Response'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
  };
  /** Sends a test message via push, this is a test endpoint to verify your push settings */
  CheckPush: {
    responses: {
      /** Successful response */
      201: {
        content: {
          'application/json': components['schemas']['CheckPushResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CheckPushRequest'];
      };
    };
  };
  /** Validates Amazon SQS credentials */
  CheckSQS: {
    responses: {
      /** Successful response */
      201: {
        content: {
          'application/json': components['schemas']['CheckSQSResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CheckSQSRequest'];
      };
    };
  };
  /** Returns all custom commands */
  ListCommands: {
    responses: {
      /** Successful response */
      200: {
        content: {
          'application/json': components['schemas']['ListCommandsResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
  };
  /** Creates custom chat command */
  CreateCommand: {
    responses: {
      /** Successful response */
      201: {
        content: {
          'application/json': components['schemas']['CreateCommandResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
    /** Command */
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateCommandRequest'];
      };
    };
  };
  /** Returns custom command by its name */
  GetCommand: {
    parameters: {
      path: {
        name: unknown;
      };
    };
    responses: {
      /** Successful response */
      200: {
        content: {
          'application/json': components['schemas']['GetCommandResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
  };
  /** Updates custom chat command */
  UpdateCommand: {
    parameters: {
      path: {
        name: unknown;
      };
    };
    responses: {
      /** Successful response */
      201: {
        content: {
          'application/json': components['schemas']['UpdateCommandResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
    /** Command */
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateCommandRequest'];
      };
    };
  };
  /** Deletes custom chat command */
  DeleteCommand: {
    parameters: {
      path: {
        name: unknown;
      };
    };
    responses: {
      /** Successful response */
      200: {
        content: {
          'application/json': components['schemas']['DeleteCommandResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
  };
  /** Establishes WebSocket connection for user */
  Connect: {
    parameters: {
      query: {
        json?: unknown;
      };
    };
    responses: {
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
  };
  /** Returns all available devices */
  ListDevices: {
    parameters: {
      query: {
        user_id?: unknown;
      };
    };
    responses: {
      /** Successful response */
      200: {
        content: {
          'application/json': components['schemas']['ListDevicesResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
  };
  /** Adds a new device to a user, if the same device already exists the call will have no effect */
  CreateDevice: {
    responses: {
      /** Successful response */
      201: {
        content: {
          'application/json': components['schemas']['Response'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateDeviceRequest'];
      };
    };
  };
  /** Deletes device */
  DeleteDevice: {
    parameters: {
      query: {
        id?: unknown;
        user_id?: unknown;
      };
    };
    responses: {
      /** Successful response */
      200: {
        content: {
          'application/json': components['schemas']['Response'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
  };
  /** Exports channel data to JSON file */
  ExportChannels: {
    responses: {
      /** Successful response */
      201: {
        content: {
          'application/json': components['schemas']['ExportChannelsResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ExportChannelsRequest'];
      };
    };
  };
  GetExportChannelsStatus: {
    parameters: {
      path: {
        id: unknown;
      };
    };
    responses: {
      /** Successful response */
      200: {
        content: {
          'application/json': components['schemas']['GetExportChannelsStatusResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
  };
  /** Creates guest user */
  CreateGuest: {
    responses: {
      /** Successful response */
      201: {
        content: {
          'application/json': components['schemas']['GuestResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GuestRequest'];
      };
    };
  };
  /** Find and filter channel members */
  QueryMembers: {
    parameters: {
      query: {
        payload?: unknown;
      };
    };
    responses: {
      /** Successful response */
      200: {
        content: {
          'application/json': components['schemas']['MembersResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
  };
  /** Returns message by ID */
  GetMessage: {
    parameters: {
      path: {
        id: unknown;
      };
    };
    responses: {
      /** Successful response */
      200: {
        content: {
          'application/json': components['schemas']['MessageResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
  };
  /** Updates certain fields of the message */
  UpdateMessagePartial: {
    responses: {
      /** Successful response */
      201: {
        content: {
          'application/json': components['schemas']['MessageResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateMessagePartialRequest'];
      };
    };
  };
  /** Updates message with new data */
  UpdateMessage: {
    responses: {
      /** Successful response */
      201: {
        content: {
          'application/json': components['schemas']['MessageResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateMessageRequest'];
      };
    };
  };
  /** Deletes message */
  DeleteMessage: {
    parameters: {
      path: {
        id: unknown;
      };
      query: {
        hard?: unknown;
      };
    };
    responses: {
      /** Successful response */
      200: {
        content: {
          'application/json': components['schemas']['MessageResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
  };
  /** Executes message command action with given parameters */
  RunMessageAction: {
    parameters: {
      path: {
        id: unknown;
      };
    };
    responses: {
      /** Successful response */
      201: {
        content: {
          'application/json': components['schemas']['MessageResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['MessageActionRequest'];
      };
    };
  };
  /** Sends reaction to specified message */
  SendReaction: {
    parameters: {
      path: {
        id: unknown;
      };
    };
    responses: {
      /** Successful response */
      201: {
        content: {
          'application/json': components['schemas']['ReactionResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SendReactionRequest'];
      };
    };
  };
  /** Removes user reaction from the message */
  DeleteReaction: {
    parameters: {
      path: {
        id: unknown;
        type: unknown;
      };
      query: {
        user_id?: unknown;
      };
    };
    responses: {
      /** Successful response */
      200: {
        content: {
          'application/json': components['schemas']['ReactionRemovalResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
  };
  /** Returns list of reactions of specific message */
  GetReactions: {
    parameters: {
      path: {
        id: unknown;
      };
    };
    responses: {
      /** Successful response */
      200: {
        content: {
          'application/json': components['schemas']['GetReactionsResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
  };
  /** Translates message to a given language using automated translation software */
  TranslateMessage: {
    responses: {
      /** Successful response */
      201: {
        content: {
          'application/json': components['schemas']['MessageResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TranslateMessageRequest'];
      };
    };
  };
  /** Returns replies (thread) of the message */
  GetReplies: {
    parameters: {
      path: {
        parent_id: unknown;
      };
      query: {
        id_gte?: unknown;
        id_gt?: unknown;
        id_lte?: unknown;
        id_lt?: unknown;
        created_at_after_or_equal?: unknown;
        created_at_after?: unknown;
        created_at_before_or_equal?: unknown;
        created_at_before?: unknown;
      };
    };
    responses: {
      /** Successful response */
      200: {
        content: {
          'application/json': components['schemas']['GetRepliesResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
  };
  /** Restricts user activity either in specific channel or globally */
  Ban: {
    responses: {
      /** Successful response */
      201: {
        content: {
          'application/json': components['schemas']['Response'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['BanRequest'];
      };
    };
  };
  /** Removes previously applied ban */
  Unban: {
    parameters: {
      query: {
        target_user_id?: unknown;
        type?: unknown;
        id?: unknown;
      };
    };
    responses: {
      /** Successful response */
      200: {
        content: {
          'application/json': components['schemas']['Response'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
  };
  /** Reports message or user for review by moderators */
  Flag: {
    responses: {
      /** Successful response */
      201: {
        content: {
          'application/json': components['schemas']['FlagResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['FlagRequest'];
      };
    };
  };
  /** Find and filter message flags */
  QueryMessageFlags: {
    parameters: {
      query: {
        payload?: unknown;
      };
    };
    responses: {
      /** Successful response */
      200: {
        content: {
          'application/json': components['schemas']['QueryMessageFlagsResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
  };
  /** Mutes one or several users */
  MuteUser: {
    responses: {
      /** Successful response */
      201: {
        content: {
          'application/json': components['schemas']['MuteUserResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['MuteUserRequest'];
      };
    };
  };
  /** Mutes channel for user */
  MuteChannel: {
    responses: {
      /** Successful response */
      201: {
        content: {
          'application/json': components['schemas']['MuteChannelResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['MuteChannelRequest'];
      };
    };
  };
  /** Removes previously created user or message flag */
  Unflag: {
    responses: {
      /** Successful response */
      201: {
        content: {
          'application/json': components['schemas']['FlagResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['FlagRequest'];
      };
    };
  };
  /** Unmutes previously muted user */
  UnmuteUser: {
    responses: {
      /** Successful response */
      201: {
        content: {
          'application/json': components['schemas']['UnmuteResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UnmuteUserRequest'];
      };
    };
  };
  /** Unmutes channel for user */
  UnmuteChannel: {
    responses: {
      /** Successful response */
      201: {
        content: {
          'application/json': components['schemas']['UnmuteResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UnmuteChannelRequest'];
      };
    };
  };
  /** Get an OpenGraph attachment for a link */
  GetOG: {
    parameters: {
      query: {
        url?: unknown;
      };
    };
    responses: {
      /** Get OG Attachment */
      200: {
        content: {
          'application/json': components['schemas']['GetOGResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
  };
  /** Lists all available permissions */
  ListPermissions: {
    responses: {
      /** Successful response */
      200: {
        content: {
          'application/json': components['schemas']['ListPermissionsResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
  };
  /** Gets custom permission */
  GetPermission: {
    parameters: {
      path: {
        id: unknown;
      };
    };
    responses: {
      /** Successful response */
      200: {
        content: {
          'application/json': components['schemas']['GetCustomPermissionResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
  };
  /** Find and filter channel scoped or global user bans */
  QueryBannedUsers: {
    parameters: {
      query: {
        payload?: unknown;
      };
    };
    responses: {
      /** Successful response */
      200: {
        content: {
          'application/json': components['schemas']['QueryBannedUsersResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
  };
  /** Get rate limits usage and quotas */
  GetRateLimits: {
    parameters: {
      query: {
        server_side?: unknown;
        android?: unknown;
        ios?: unknown;
        web?: unknown;
        endpoints?: unknown;
      };
    };
    responses: {
      /** Get Rate Limits Response */
      200: {
        content: {
          'application/json': components['schemas']['GetRateLimitsResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
  };
  /** Lists all available roles */
  ListRoles: {
    responses: {
      /** Successful response */
      200: {
        content: {
          'application/json': components['schemas']['ListRolesResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
  };
  /** Creates custom role */
  CreateRole: {
    responses: {
      /** Successful response */
      201: {
        content: {
          'application/json': components['schemas']['CreateRoleResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateRoleRequest'];
      };
    };
  };
  /** Deletes custom role */
  DeleteRole: {
    parameters: {
      path: {
        name: unknown;
      };
    };
    responses: {
      /** Successful response */
      200: {
        content: {
          'application/json': components['schemas']['Response'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
  };
  /** Search messages across channels */
  Search: {
    parameters: {
      query: {
        payload?: unknown;
      };
    };
    responses: {
      /** Successful response */
      200: {
        content: {
          'application/json': components['schemas']['SearchResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
  };
  /** List segments */
  ListSegments: {
    responses: {
      /** Successful response */
      200: {
        content: {
          'application/json': components['schemas']['ListSegmentsResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
  };
  /** Create a segment */
  CreateSegment: {
    responses: {
      /** Successful response */
      201: {
        content: {
          'application/json': components['schemas']['CreateSegmentResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateSegmentRequest'];
      };
    };
  };
  /** Get a segment */
  GetSegment: {
    parameters: {
      path: {
        id: unknown;
      };
    };
    responses: {
      /** Successful response */
      200: {
        content: {
          'application/json': components['schemas']['GetSegmentResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
  };
  /** Update an existing segment */
  UpdateSegment: {
    parameters: {
      path: {
        id: unknown;
      };
    };
    responses: {
      /** Successful response */
      201: {
        content: {
          'application/json': components['schemas']['UpdateSegmentResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateSegmentRequest'];
      };
    };
  };
  /** Delete a segment */
  DeleteSegment: {
    parameters: {
      path: {
        id: unknown;
      };
    };
    responses: {
      /** Successful response */
      200: {
        content: {
          'application/json': components['schemas']['DeleteSegmentResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
  };
  /** Returns all events happened since client disconnect in specified channels */
  Sync: {
    parameters: {
      query: {
        with_inaccessible_cids?: unknown;
      };
    };
    responses: {
      /** Successful response */
      201: {
        content: {
          'application/json': components['schemas']['SyncResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SyncRequest'];
      };
    };
  };
  /** Gets status of a task */
  GetTask: {
    parameters: {
      path: {
        id: unknown;
      };
    };
    responses: {
      /** Get Task Response */
      200: {
        content: {
          'application/json': components['schemas']['GetTaskResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
  };
  /** Find and filter users */
  QueryUsers: {
    parameters: {
      query: {
        payload?: unknown;
      };
    };
    responses: {
      /** Successful response */
      200: {
        content: {
          'application/json': components['schemas']['UsersResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
  };
  /** Update or create users in bulk */
  UpdateUsers: {
    responses: {
      /** Successful response */
      201: {
        content: {
          'application/json': components['schemas']['UpdateUsersResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateUsersRequest'];
      };
    };
  };
  /** Updates certain fields of the user */
  UpdateUsersPartial: {
    responses: {
      /** Successful response */
      200: {
        content: {
          'application/json': components['schemas']['UpdateUsersResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateUserPartialRequest'];
      };
    };
  };
  /** Deletes user and optionally all their belongings */
  DeleteUser: {
    parameters: {
      path: {
        user_id: unknown;
      };
      query: {
        mark_messages_deleted?: unknown;
        hard_delete?: unknown;
        delete_conversation_channels?: unknown;
      };
    };
    responses: {
      /** Successful response */
      200: {
        content: {
          'application/json': components['schemas']['DeleteUserResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
  };
  /** Deactivates user with possibility to activate it back */
  DeactivateUser: {
    parameters: {
      path: {
        user_id: unknown;
      };
    };
    responses: {
      /** Successful response */
      201: {
        content: {
          'application/json': components['schemas']['DeactivateUserResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeactivateUserRequest'];
      };
    };
  };
  /** Sends a custom event to a user */
  SendUserCustomEvent: {
    parameters: {
      path: {
        user_id: unknown;
      };
    };
    responses: {
      /** Successful response */
      201: {
        content: {
          'application/json': components['schemas']['Response'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SendUserCustomEventRequest'];
      };
    };
  };
  /** Exports the user's profile, reactions and messages. Raises an error if a user has more than 10k messages or reactions */
  ExportUser: {
    parameters: {
      path: {
        user_id: unknown;
      };
    };
    responses: {
      /** Successful response */
      200: {
        content: {
          'application/json': components['schemas']['ExportUserResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
  };
  /** Activates user who's been deactivated previously */
  ReactivateUser: {
    parameters: {
      path: {
        user_id: unknown;
      };
    };
    responses: {
      /** Successful response */
      201: {
        content: {
          'application/json': components['schemas']['ReactivateUserResponse'];
        };
      };
      /** Bad request */
      400: {
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
      /** Too many requests */
      429: {
        headers: {
          /** The number of allowed requests in the current period */
          'X-RateLimit-Limit'?: number;
          /** The number of remaining requests in the current period */
          'X-RateLimit-Remaining'?: number;
          /** Timestamp when number of requests will be reset */
          'X-RateLimit-Reset'?: number;
        };
        content: {
          'application/json': components['schemas']['APIError'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ReactivateUserRequest'];
      };
    };
  };
}

export interface external {}
